[{"content":"个人资料 email: bGl1Y2hhbmcwODEyQGdtYWlsLmNvbQ== tel: MTM2NTIzNTE4MTI= 教育背景 武汉大学计算机学院 2010.09 - 2014.06 ACM/ICPC 铜牌 软考系统分析师证书 工作经历 腾讯微信 腾讯云 聚道 阿里云 微软 主要项目 其它 更新时间：2025 年 6 月 7 日\n","permalink":"https://www.liuchang0812.com/about/","summary":"\u003ch1 id=\"个人资料\"\u003e个人资料\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eemail: bGl1Y2hhbmcwODEyQGdtYWlsLmNvbQ==\u003c/li\u003e\n\u003cli\u003etel: MTM2NTIzNTE4MTI=\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"教育背景\"\u003e教育背景\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e武汉大学计算机学院 2010.09 - 2014.06\u003c/li\u003e\n\u003cli\u003eACM/ICPC 铜牌\u003c/li\u003e\n\u003cli\u003e软考系统分析师证书\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"工作经历\"\u003e工作经历\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e腾讯微信\u003c/li\u003e\n\u003cli\u003e腾讯云\u003c/li\u003e\n\u003cli\u003e聚道\u003c/li\u003e\n\u003cli\u003e阿里云\u003c/li\u003e\n\u003cli\u003e微软\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"主要项目\"\u003e主要项目\u003c/h1\u003e\n\u003ch1 id=\"其它\"\u003e其它\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e更新时间：2025 年 6 月 7 日\u003c/p\u003e\n\u003c/blockquote\u003e","title":"ABOUT"},{"content":"评分：⭐️⭐️⭐️⭐️\n这本书是我喜欢的风格，偏学术风格，有大量的引用出处。读完之后对于三大战役的了解多了一些，对于毛蒋的认识也多了一些。\n对于领导人来说，“定战略/相信前线将领/抓核心问题“是最重要的。蒋在书中的描写是被毛牵着鼻子走，喜欢微操。在大战之前没有准备，在大战过程中处处被动应对。国民党军阀本质，不同的军队之中各自为政，为了保存实力表演式救援。\n北平和平解放 关于这块儿内容，不像我们想的那么简单。和 ai 对话“假设你是当时的傅作义，你会遇到哪些问题？“就知道起义不是一件容易的事儿，一不小心就要命的。\n首先，傅作义非蒋介石的嫡系，当时的北平还有很多忠诚于蒋介石的中央军，有很多将领是不同意投降的。其次，傅作义也是上了红军罪人名单的，怎么保证自己投降之后的利益。\n书中详细介绍了他打散中央军，和嫡系将领沟通，对蒋介石说议和是为了欺骗共党争取利益，多次派代表沟通争取更大利益。提供飞机让蒋嫡系将领飞回南京。化整为零让部队出城接受改编。\n","permalink":"https://www.liuchang0812.com/posts/read/2026-02-%E5%A4%A7%E5%86%B3%E6%88%98/","summary":"关于国共内战期间的三大战役的一本书，从两方领导人的角度为切入点，描述了战役过程中很多事情","title":"2026 02 读书分享:大决战"},{"content":"分享最近读的一本好书《昂贵的和平》，这本书主要写马关条约签订过程。风格偏向学术风格，每页都有引用说明。\n内容包括详细的：\n皇室在事件中的行为：慈禧太后遇到关键决策就称病 主战和主和派大臣之间的冲突 日本在谈判过程中极力争取利益，又担心列强介入 英法俄等国家在调停中争取利益 日本借口朝鲜主权，进军辽东。清方打不过，于是派遣大臣谈判。日方为了扩大战场，增加谈判筹码，以对方不符合国际法，没有全权证书为由拒绝了第一次议和。\n之后，由李鸿章和儿子作为全权大臣到马关议和。谈判过程中，李鸿章被刺杀，子弹射入面部。中方没有借助此事件，增加谈判筹码，是一大失误。另外不重要电报加密，导致自己的筹码被别人看得清清楚楚。\n合约签订之后需要皇室批准并交换条约，在约定的期限之前，两国努力让列强的介入和让步，最终免于割地辽东。\n","permalink":"https://www.liuchang0812.com/posts/read/2025-11-maguantiaoyue/","summary":"《昂贵的和平》马关条约签订始末","title":"2025 11 读书分享:昂贵的和平"},{"content":"这个周末完成了一个 2025 年的 flag：横渡维多利亚港！早上 5 点起床，坐高铁到香港，和小伙伴汇合后排队入场。大约 9 点在中环会展中心下水，10 点左右在 K11 东边上岸。\n活动的直线距离大约 1.1 km。当天天气很好，阳光充足、并不算冷，但海面有很强的逆流和较大的浪🌊。第一批选手被逆流冲得特别靠左，我们在岸上还嘲笑他们，心想下水后朝右边（红馆方向）游、叠加逆流就能走直线。理想丰满，现实很骨感——我很快也被浪冲得很靠左，离线路上的两个浮标越来越远。\n这是我第一次在海里游泳。刚下水时第一口海水太难受了，又咸又带着柴油味，能见度估计不超过 10 厘米；太紧张了，我不敢直接自由泳，踩了好一会儿蛙泳，心里甚至担心自己会在海里“嗝屁”。当时脑子里不断冒出 \u0026ldquo;我真是脑子进水了，花钱来喝海水\u0026rdquo; 的念头，甚至决定下次再也不来了。\n前半程还算顺利，很快到了第一个浮标（大约 1/2）。抱着跟屁虫在海上慢慢欣赏维港的风景，视角特别，很美，只可惜太老实没带相机——下次一定要把 DJI NANO 偷塞在泳帽里。后来浪更大了，我发现自己离浮标偏左很多，对着对面巨大的绿色“人寿”广告牌调整方向，开始拼命自由泳。\n努力了很久，看起来几乎没有前进——抬头看浮标和 K11 大楼都没什么变化，绝望感涌上来。休息时我只能做蛙泳看方向，然后再拼命自由泳。看到后面还有很多同组选手，就硬着头皮继续。\n中途左脚抽筋了，按了按继续游，慢慢能看到岸上 K11 那边人越来越多。因为被冲得太左，一开始看不到终点标识，但心里想着应该不远了，就继续朝广告牌方向闷头冲。忽然抬头看到了终点标识，那一刻特别开心。我低头一口气游到终点浮漂，爬上去后回头看了眼风景，心情很满足。\n浮漂上大家互相击掌庆祝，排队登记号码后上岸。岸上人山人海，气氛很热闹，打卡留念后就撤了。总结一下这次体验：\n距离：约 1.1 km 天气：晴好，但有强逆流和较大浪 状态：第一次海泳，出现短暂恐慌、抽筋、能见度低 收获：克服了恐惧，看到了独特的海上视角，体验非常难忘 哈哈，很开心完成了这项挑战。明年再看情况决定要不要继续参加。\n（注：这是个人记录，若日后要发更多照片或视频可补充在后续更新。）\n","permalink":"https://www.liuchang0812.com/posts/life/2025-11-22-crossing-victoria-harbour/","summary":"周末完成的 2025 年 flag：横渡维多利亚港，1.1km 的第一次海泳体验。","title":"横渡维多利亚港"},{"content":"背景 Lsm 存储引擎的写入流程为：先写 wal 日志，再更新内存中的 skiplist。在典型的场景下，可能会有很多线程并发的写入数据，如何提供高性能的写操作呢？\nLeveldb 批量写入的优化 代码逻辑在 Status DBImpl::Write(const WriteOptions\u0026amp; options, WriteBatch* updates) 中。\n考虑最朴素的实现方法：每个线程的写请求来了之后排队抢锁，抢到锁的线程开始后续的写日志更新内存的操作，完成之后释放锁。可以预见这种方式相当于写操作完全串行而且会有大量的小 io，性能会很一般。\nLeveldb 中采用了批量化写入的实现：请示到达之后会封装为一个 writer 结构体中，然后加到队列中。当线程不是 leader 的时候，就通过 condvar 等待唤醒，当线程是 leader 的时候（任务在最前面），就打包队列中的多个 请求作为了一个整体的请示写 wal 日志。写日志的时候会释放锁，让其它线程的写请示继续添加到任务队列中。写操作成功后，leader 会依次把这批任务的状态更新为完成并唤醒对应的 condvar，最后唤醒当前任务队列的 leader 结点让它开始处理下一批任务。\nStatus DBImpl::Write(const WriteOptions\u0026amp; options, WriteBatch* updates) { Writer w(\u0026amp;mutex_); w.batch = updates; w.sync = options.sync; w.done = false; MutexLock l(\u0026amp;mutex_); writers_.push_back(\u0026amp;w); while (!w.done \u0026amp;\u0026amp; \u0026amp;w != writers_.front()) { w.cv.Wait(); } if (w.done) { return w.status; } // May temporarily unlock and wait. Status status = MakeRoomForWrite(updates == nullptr); uint64_t last_sequence = versions_-\u0026gt;LastSequence(); Writer* last_writer = \u0026amp;w; if (status.ok() \u0026amp;\u0026amp; updates != nullptr) { // nullptr batch is for compactions WriteBatch* write_batch = BuildBatchGroup(\u0026amp;last_writer); // BuildBatchGroup 负责选择本批打包哪些任务，last_writer 指向本组最后一个任务 WriteBatchInternal::SetSequence(write_batch, last_sequence + 1); last_sequence += WriteBatchInternal::Count(write_batch); { mutex_.Unlock(); status = log_-\u0026gt;AddRecord(WriteBatchInternal::Contents(write_batch)); bool sync_error = false; if (status.ok() \u0026amp;\u0026amp; options.sync) { status = logfile_-\u0026gt;Sync(); if (!status.ok()) { sync_error = true; } } if (status.ok()) { status = WriteBatchInternal::InsertInto(write_batch, mem_); } mutex_.Lock(); } if (write_batch == tmp_batch_) tmp_batch_-\u0026gt;Clear(); versions_-\u0026gt;SetLastSequence(last_sequence); } while (true) { Writer* ready = writers_.front(); writers_.pop_front(); if (ready != \u0026amp;w) { ready-\u0026gt;status = status; ready-\u0026gt;done = true; ready-\u0026gt;cv.Signal(); } if (ready == last_writer) break; } // Notify new head of write queue if (!writers_.empty()) { writers_.front()-\u0026gt;cv.Signal(); } return status; } ","permalink":"https://www.liuchang0812.com/posts/tech/batch-write-in-leveldb/","summary":"学习如何通过批量化的方式优化我们的系统","title":"通过 leveldb 学习批量请求优化"},{"content":"说到格力，大家都想到董明珠。其实，格力的创始人和第一任董事长是朱江洪。\n这本书还不错，推荐读一读。作者介绍了自己从华南理工毕业后，先是到广西从小工干到厂长的故事，然后南巡讲话后到家乡和改革最前沿珠海当厂长的故事。\n其中有意思的部分有一章专门讲在国企中怎么互相争权斗争的故事。书中也有大量作者自己的思考与总结内容。\n我觉得，每个人都有自尊心，这是从娘肚子省下来就具有的天性，领导也不例外，他们都有权争取社会承认，被人尊重的心理需求。你尊重别人，才有与别人接触和交流的先决条件。在交流中，要让对方有更多的说话和表达的机会，不要随意指责对方这也错那也不成。即使真的错了，只要“无伤大雅“，没有造成不良影响，也要以宽容心态相待。但如果是自己错了，就要老老实实承认，这样才能赢得更多的合作交流机会，赢得对方的好感和尊重\n在交往中，要学会赞美他人，背后不要说人短，不要在乎人家怎么看你，也不要期待谁必须对你好，相信自己比依赖别人更重要，用尽心机不如静心做事。人与人相处有时难免多心，心眼一多，许多小事自然就会计较，就会“过敏“。别人多看你一眼，你便觉得他对你有敌意；别人少看你一眼，你又认定他冷落了你。多心的人总是胡思乱想，结果被困在一团思绪的乱麻之中，与其多心自扰，不如宽心豁达\n我之所以能与别人和睦相处，很重要的一点是不在乎被人占便宜。俗话说，“吃亏是福”，有些人把吃亏看得很重，吃了一点亏便耿耿于怀。我们能否从另外一个角度看问题，把吃亏作为一种投资，有投资就有机会收获，吃亏越多，收获的机会就越大。而且，你敢于吃亏，愿意吃亏，别人才会接近你，愿意跟你好\n","permalink":"https://www.liuchang0812.com/posts/read/2025-05-zhujianghong/","summary":"格力老总的自传","title":"2025 05 读书分享:朱江洪自传"},{"content":"回忆一下 paxos 算法： 多个结点对于一个事情达成共识。共识只有一个且不会被修改。限定在非拜占庭场景。 Simple Paxos 提出了一个做法。算法采用两阶段，第一阶段结点提出提议争取其它结点的承诺，如果提出者的提议号比自己收到的提议大，就承诺在二阶段不通过小于提议号的提议，并返回如果已有提议内容。如果结点争取到大多数的结点承诺，就发起二阶段流程。如果不违法自己的承诺，各结点就通过提议。在大多数结点通过提议的时候，这个提议就被选定了，成为了共识，之后再也不会变化。\n论文中的描述是按照这样的逻辑来描述的：如果满足条件 A 的情况下 B 成立。 这个时候我们加强 A 的条件， B 当然也会成立。我们也可以用反证法来证明满足约束的条件下共识一定不会有不同的值。\n业界主流的实现是按照上述流程来实现，也有一个更神奇优雅当然也更难懂的实现。完全异步的基于不同结点的视图信息同步来推进算法流程的算法，具体可以参考微信开源的 KVStore Certain。\n上述算法是确定一个共识，在工业界实际使用的时候，其实是要确定连续的多个共识，这样才能维护出一个大家都完全一致的日志流，状态机通过回放日志流得到一致的状态。如果每个日志都用二阶段，算法性能明显很低，所以大家想到了很巧妙的解法：一种是先用共识来选主，来跳过第一阶段。还有一种是在前一个日志中隐藏信息，如果是前一个日志中的结点可以跳过第一阶段，大家默认已经承诺了它的提议序列号。另外还有成员变更的问题，有一种作法就是写入一个特殊的日志，将新成员列表写到日志内容中，后续成员以日志内容为准。\npaxos 算法相对 raft 算法的好处是逻辑上更优雅简单细节少，没有选主过程所以也没有主挂掉时候的超时时间内不可用问题。缺点就是只是个算法，没有具体的工程实现细节，一些场景下没有 raft 性能好。\n","permalink":"https://www.liuchang0812.com/posts/tech/paper/paxosmadesimple/","summary":"paxos note","title":"Paxos Made Simple"},{"content":"在 2003 年那个时间点，可能还没有现在主流的 Paxos/Raft 一致性算法工程实现。 Paxos made simple 论文是 2001 年发表的。 Raft 是 2014 年发表的论文。 所以 GFS 的 master 和 chunkserver 都没有采用 Paxos/Raft 强一致性算法来维护强一致性。 Master 是个单点，由主从日志同步来保证可用性。 Chunkserver 管理三副本，采用与 Client 协调的宽松一致性。\n设计上，传统的文件系统接口复杂且低效， GFS 放弃传统文件系统语义的完全兼容，提供了适合大多数业务场景的语义模型：大文件，追加写，客户端校验文件完整性。从而实现了一个满足企业内部需求的高性能简单可靠的分布式文件系统。数据修改可以是普通写入或记录追加。 写操作会在应用程序指定的文件偏移量处写入数据。 记录追加操作至少会原子地在并发修改的情况下附加一次数据（第 3.3 节），但以 GFS 指定的偏移量进行附加。\n写数据的流程也与常见的系统不一样。在 GFS 中一次写操作，数据和控制流是分开的。客户端先向 chunkserver 链式推送数据，然后再由 primary chunkserver 来决定数据写入顺序和位置。在主流的一些系统中，写操作都没这么做，比如 GFS 的开源实现 HDFS以及另一个常见存储系统 Ceph。 GFS 这个实现上肯定是要复杂很多。我求证了一下 AI，结论是这样的。GFS的机制（数据推送+主副本协调）在开源系统中未被广泛采用，主要原因包括：\n复杂度高 ：租约机制、主副本故障切换等实现难度大，HDFS等系统选择简化设计以降低工程成本。 场景差异 ：多数开源系统面向批处理（如HDFS）或小文件存储（如TFS），无需GFS的高并发追加能力. PS：现在大模型作为工具，来辅助阅读论文已经非常非常好用了，大大的提高像我这样英语不是特别好的人的阅读效率。推荐大家可以使用像沉浸式阅读这样的工具，再配置上 deepseek v3 这样的大模型，翻译的同时还可以提问。另外还可以使用元宝/qwen的论文阅读工具。\n","permalink":"https://www.liuchang0812.com/posts/tech/paper/gfs/","summary":"2025 年回头看 2003 年的 Google File System 设计","title":"Google File System 设计"},{"content":"用过 pytorch 的小朋友都知道，只要调用一行 loss.backward(), 框架就会自动把所有变量的偏导数计算出来。这个看起来很神奇，一起来研究一下它是怎么实现的吧。本文简单介绍它的原理，然后提供一个简易的 CPP 实现帮助你理解。\n基础知识 链式法则 在导数计算方法里面有一个链式法则（大家应该都学过，但是忘得差不多了）。对于一个函数 $f(g(x)) $ 的导数等于 $ f'(g(x))*g'(x) $。这个公式也可以写成\n$$\\frac{\\partial z}{\\partial y} = \\frac{\\partial z}{\\partial u}*\\frac{\\partial u}{\\partial y}$$\n反向传导 有了上面的链式法则，我们就可以很巧妙的求导数了。假如我们有如下公式，要求 $\\frac{\\partial z}{\\partial x}$ 的值，就可又转换为 $\\frac{\\partial z}{\\partial y} * \\frac{\\partial y}{\\partial x}$\ny = x^3+x^2 z = 2*y-4 求导过程 把计算过程当成一个图来看，z 是最终的输出结点，看成是根结点。x 是输入结点，看成是叶子结点。就可以得到一个有向图。在自动求导的过程中，从根结点开始向下递归，z 结点的梯度是 $\\frac{\\partial z}{\\partial z}=1$。然后 y 结点的梯度是 z 的子结点，y 的结点就是 $\\frac{\\partial z}{\\partial y}$。然后再计算 x 结点就是 $\\frac{\\partial z}{\\partial x} = \\frac{\\partial z}{\\partial y} \\cdot \\frac{\\partial y}{\\partial x}$。\n可以看出来就是一个递归的过程，我们可以在每个结点中保存这个结点的梯度。在求一个结点的梯度时，它就等于所有前面结点的梯度值再乘以前面结点对当前结点的偏导数。假设前面的结点为 K，可以如下表达。\n$$ Grad_x = \\sum_{k} Grad_k \\cdot \\frac{\\partial k}{\\partial x} $$\n代码实现 如何用代码实现上面的逻辑呢？我们需要从根结点开始向下遍历，根结点的初始梯度为 $ \\frac{\\partial k}{\\partial x} = 1 $, 对他的所有子结点，增加根结点的梯度乘以根结点对其的偏导数。相同的逻辑再处理这些子结点。这儿提供一个 deepseek 实现的简单版本，你多花一些时间看一下，就明白了自动微分的逻辑。当然这个是比较初级的，还有很多细节和问题。\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;math.h\u0026gt; // 定义操作类型枚举 typedef enum { OP_CONST, // 常量 OP_ADD, // 加法 OP_MUL, // 乘法 OP_POW // 幂运算 } OpType; // 微分值结构体 typedef struct Value { double data; // 数据值 double grad; // 梯度值 OpType op; // 操作类型 struct Value* prev[2]; // 前驱节点（最多两个输入） void (*backward)(struct Value*); // 反向传播函数 } Value; // 创建叶子节点（无操作） Value* create_leaf(double data) { Value* v = (Value*)malloc(sizeof(Value)); v-\u0026gt;data = data; v-\u0026gt;grad = 0.0; v-\u0026gt;op = OP_CONST; v-\u0026gt;prev[0] = v-\u0026gt;prev[1] = NULL; v-\u0026gt;backward = NULL; return v; } // 加法运算 Value* add(Value* a, Value* b) { Value* v = (Value*)malloc(sizeof(Value)); v-\u0026gt;data = a-\u0026gt;data + b-\u0026gt;data; v-\u0026gt;grad = 0.0; v-\u0026gt;op = OP_ADD; v-\u0026gt;prev[0] = a; v-\u0026gt;prev[1] = b; v-\u0026gt;backward = NULL; return v; } // 乘法运算 Value* mul(Value* a, Value* b) { Value* v = (Value*)malloc(sizeof(Value)); v-\u0026gt;data = a-\u0026gt;data * b-\u0026gt;data; v-\u0026gt;grad = 0.0; v-\u0026gt;op = OP_MUL; v-\u0026gt;prev[0] = a; v-\u0026gt;prev[1] = b; v-\u0026gt;backward = NULL; return v; } // 幂运算 Value* pow_(Value* a, double exponent) { Value* v = (Value*)malloc(sizeof(Value)); v-\u0026gt;data = pow(a-\u0026gt;data, exponent); v-\u0026gt;grad = 0.0; v-\u0026gt;op = OP_POW; v-\u0026gt;prev[0] = a; v-\u0026gt;prev[1] = create_leaf(exponent); // 指数作为常量节点 v-\u0026gt;backward = NULL; return v; } // 反向传播实现 void backward(Value* v) { // 初始化输出梯度为1（dz/dz = 1） v-\u0026gt;grad = 1.0; // 反向传播递归函数 void _backward(Value* v) { if (v == NULL) return; switch (v-\u0026gt;op) { case OP_ADD: v-\u0026gt;prev[0]-\u0026gt;grad += v-\u0026gt;grad * 1.0; // da/dx = 1 v-\u0026gt;prev[1]-\u0026gt;grad += v-\u0026gt;grad * 1.0; // db/dy = 1 break; case OP_MUL: v-\u0026gt;prev[0]-\u0026gt;grad += v-\u0026gt;grad * v-\u0026gt;prev[1]-\u0026gt;data; // da/dx = y v-\u0026gt;prev[1]-\u0026gt;grad += v-\u0026gt;grad * v-\u0026gt;prev[0]-\u0026gt;data; // db/dy = x break; case OP_POW: { double exponent = v-\u0026gt;prev[1]-\u0026gt;data; v-\u0026gt;prev[0]-\u0026gt;grad += v-\u0026gt;grad * exponent * pow(v-\u0026gt;prev[0]-\u0026gt;data, exponent-1); break; } case OP_CONST: break; } // 递归传播 _backward(v-\u0026gt;prev[0]); _backward(v-\u0026gt;prev[1]); } _backward(v); } // 示例使用 int main() { // 创建输入变量 Value* x = create_leaf(2.0); Value* y = create_leaf(3.0); // 构建计算图：z = x^2 * y + y + 2 Value* x_sq = pow_(x, 2); Value* term1 = mul(x_sq, y); Value* term2 = add(term1, y); Value* z = add(term2, create_leaf(2.0)); // 执行反向传播 backward(z); // 打印结果 printf(\u0026#34;dz/dx = %.2f\\n\u0026#34;, x-\u0026gt;grad); // 应输出 12.00 printf(\u0026#34;dz/dy = %.2f\\n\u0026#34;, y-\u0026gt;grad); // 应输出 5.00 // 释放内存（简化示例，实际需要更严谨的内存管理） free(x); free(y); free(x_sq); free(term1); free(term2); free(z); return 0; } ","permalink":"https://www.liuchang0812.com/posts/tech/ai/autograd/","summary":"学习一下怎么实现机器学习框架🚀","title":"自动微分系统实现"},{"content":"一直有听说 PID 算法，最近学习了一下，看一下在我们的系统中是否能解决一些痛点问题。\nPID控制 在工业控制、机器人、智能设备等领域，PID算法如同一个隐形的\u0026quot;调节大师\u0026quot;，默默支撑着无数系统的稳定运行。这种诞生于20世纪的控制算法，凭借其简洁的结构和强大的适应性，至今仍是自动控制领域的核心技术之一。\n核心原理：三位一体的智慧 PID是比例（Proportional）、积分（Integral）、微分（Derivative）控制的简称，其核心思想是通过误差的三种维度进行动态补偿。数学表达式为：\n$$ u(t) = K_p \\cdot e(t) + K_i \\cdot \\int e(t) , dt + K_d \\cdot \\frac{de(t)}{dt} $$\n比例项（P）实时响应当前偏差，像精准的标枪手快速修正系统状态 积分项（I）累积历史误差，消除系统稳态偏差，如同经验丰富的老师傅修正细微偏差 微分项（D）预测未来趋势，抑制超调震荡，扮演着\u0026quot;防患未然\u0026quot;的预警角色 离散化公式 TODO: 补充离散化的公式/ delta 公式的推导\n在离散化的场景下，比如一分种一个点的情况下，三个参数分别：\n本次误差：用当前的值和预期值直接减 积分：纪录一个之前误差和，再加上本次误差 微分：纪录一个上次误差，用本次误差减去上次误差，再除以时间分片 换成数学公式就是 （$\\Delta$ 代表时间分片，$e(t)$ 代表第 t 时间的误差, $Esum$ 代表误差和） $$ u(t) = K_p \\cdot (e(t)-e(t-1)) + K_i \\cdot (\\int_{i=0}^{t} e(i)) + K_d \\cdot \\frac{(e(t) - e(t-1))}{\\Delta} $$\n增量化公式 上面那个方法要保存误差和，会有溢出的风险。还可以考虑用增量的表达方法，推导的方法是\n$$ \\Delta u_k = u_k - u_{k-1} $$\n把 $u_k$ 和 $u_{k-1}$ 代入上面的离散公式可以得到\n$$ \\Delta u_k = K_p \\cdot (e(k) - e(k-1)) + K_i \\cdot e(k) + K_d \\cdot (e(k) - 2e(k-1) + e(k-2)) $$\n从上面公式可以看到，u_k 只会 3 次误差相关，不用算积分啦。\n实际应用中的艺术 PID参数调校堪称控制领域的\u0026quot;玄学\u0026quot;，工程师需要根据系统特性平衡三者关系：\n增大Kₚ加快响应速度，但过量会导致震荡 提高Kᵢ消除静差，但可能引起积分饱和 加强Kₐ抑制超调，但对噪声敏感 TODO: 介绍一个调整方法\n现代演进与未来 从恒温控制到火箭姿态调整，从传统PID到模糊PID、自适应PID等变种算法，这种经典控制理论持续焕发新生。在智能制造和物联网时代，PID作为基础控制算法，仍将在自动化系统中扮演关键角色。理解PID，就是掌握了一把打开现代控制技术大门的钥匙。\ncsdn wiki ","permalink":"https://www.liuchang0812.com/posts/tech/pid/","summary":"学习一下怎么控制火箭🚀","title":"控制论算法 PID"},{"content":" 语言模型和词向量 今天在看一本关于 GPT 入门的书，学习了关于语言模型和词向量的部分。这里以外行小白的视角来介绍一下这两个东西。\n1. 语言模型：从规则到统计 语言模型的目标是让计算机“理解”人类语言，进而完成文本补全等任务。这里的“理解”并非真正的认知，而是通过概率预测下一个词的可能性。\n早期有两种思路：\n规则系统：人工编写语法规则。例如，规定“名词后面可能接动词”。但中文语法复杂，规则难以穷举，效果很差。 统计模型：从数据中学习规律。例如，给定前 N 个词，统计下一个词的概率分布。这就是 N-gram 模型 的核心思想。 以中文为例，若用 2-gram 模型，训练时需要将文本切分为词语序列（如鲁迅的小说会被分成“鲁迅”“的”“小说”等词），然后统计词频。例如，若语料中出现“鲁迅的小说”100次，“小说的年代”50次，则“鲁迅”后接“的”的概率为 100/(100+50) ≈ 67%。通过这种方式，模型可以模拟鲁迅的风格生成文本。\n2. 词向量革命：Word2Vec 与 CBOW 词向量是将词语映射到低维向量的技术，经典实现是 Word2Vec 的 CBOW（Continuous Bag of Words）模型。它的核心思想是：通过上下文预测目标词。\n假设我们有一个包含 7 个词的小语料库（如 [\u0026ldquo;我\u0026rdquo;, \u0026ldquo;爱\u0026rdquo;, \u0026ldquo;北京\u0026rdquo;, \u0026ldquo;天安门\u0026rdquo;, \u0026ldquo;天安\u0026rdquo;, \u0026ldquo;门\u0026rdquo;, \u0026ldquo;的\u0026rdquo;]），目标是训练一个 2 维的词向量。具体步骤如下：\n数据准备：将每个词转为 one-hot 编码（长度为 7）。例如，“北京”对应 [0,0,1,0,0,0,0]。 输入上下文：CBOW 的输入是目标词的上下文词。例如，若窗口大小为 2，目标词“爱”的上下文是“我”和“北京”。 嵌入层：将两个 one-hot 向量映射到 2 维空间，得到稠密向量（如 [0.2, 0.8] 和 [0.6, 0.4]）。 预测目标词：将上下文向量平均后输入全连接层，输出概率分布（如预测“天安门”的概率最高）。 训练完成后，嵌入矩阵的每一行对应一个词的向量。虽然高维空间中的语义关系无法直接解释，但相似词（如“猫”和“狗”）往往距离较近。例如，在理想情况下，可能观察到类似 国王 - 男人 + 女人 ≈ 王后 的语义运算，但这高度依赖训练数据和模型规模。\n3. 争议与局限 数据依赖性：词向量的质量严重依赖语料库。若数据量不足，模型可能学到错误关联（如“医生 - 男性 + 女性 = 护士”）。 语义黑箱：低维向量中的“语义方向”是数学推导的结果，而非明确的人类定义属性。 尽管如此，词向量仍是自然语言处理的重要基石。后续的 Transformer、BERT 等模型，在此基础上进一步提升了语言理解的深度。\n以上是我的学习笔记，欢迎指正！\n原文\n今天在看一本关于 GPT 入门的书，学习了关于语言模型和词向量的部分。这儿以外行小白的视角来介绍一下这两个东西。\n首先是语言模型，也就是怎么对人类语言模型建模，让计算机可以理解人类的语言。这儿的“理解”不一定是要真的理解，而是计算机可以完成文本补全之类的任务。第一个选择就是规则系统，把人类语言的语法作为规则编码进去。可想而知，这个很难做，效果也不好。第二个选择则是从概率统计的角度来看，计算机只要知道：给定 N 个单词，知道下一个单词可以为哪些单词，它们各自的概率是多少。\n所以就有了 N-GRAM 模型，用前 N 个单词作为前缀来判定下一个单词的概率。这个比较容易理解，训练过程也很直观了。你可以拿一个语料，比如鲁迅的小说，把他们按字切分后，每 N+1 个字生成一个 \u0026lt;C1, C2, … Cn, Cn+1\u0026gt; 元素，然后统计他们出现的次数。之后就可以模拟鲁迅生成文字。\n关于词向量，当年 word2vec 特别火。它能实现词汇的加减法。比如说： 国王 - 男人 + 女人 = 王后。 它的原理是什么呢？\n以其中的 CBOW 算法为例子，假设我们只有 7 个单词的文本库， 训练一个 2 维的词向量。 我们首先把文本库生成训练数据，对于每 N 个临近词生成：\u0026lt;W1, W2\u0026gt; 的元素，再用 one-shot 和单词下标来替换 W1 W2 得到类似 \u0026laquo;0, 0, 0, 1, 0, 0, 0\u0026gt;, 3\u0026gt; 的数据。 这儿 W1 下标为 4， W2 下标为 3。然后用一个简单的神经网络，这个网络的一层参数会是 72 的矩阵，输出一个 softmax 的 17 的矩阵。 这儿 \u0026lt;0, 0, 0, 1, 0, 0, 0\u0026gt; 作为网络输入， 3 作为答案来训练网络，最后就能得到 7*2 的权重矩阵。这个矩阵也就是这 7 个单词的词向量。 把它们画到图上，就会发现相关的词离得近，不相关的词离得远。\n本质上应该是：把文本人为切分生成了训练集，他们之间可能有种数据关系，通过神经网络的训练找到在指定维度向量上的表示。如果数据量够大，维度够多，每一维可能会对应到一个属性：比如是不是颜色，是不是生活物品。\n这个部分感觉还是挺简单优美且神奇的。我这儿介绍的比较外行，大家有兴趣可以查阅相关的文章。\n","permalink":"https://www.liuchang0812.com/posts/tech/ai/word2vec/","summary":"语言模型和词向量笔记， deepseek 优化版","title":"语言模型和词向量"},{"content":"这是一本关于陈虻的书，看到微信读书上朋友称之为神作，就读了一下。我也非常推荐。\n陈虻感觉是一个充满了大智慧喜欢思考表达能力很强的人，对于怎么做纪录片有自己特别深刻的思考，自己 100% 的投入到这个事情中，也做出了很多成就。\n我在审节目的时候，对自己有两个基本的要求：第一，不能说不好，只能说怎么样更好；第二，不是告诉你怎么改，而是激发你自己修改的欲望。\n一个创作者怎样变得成熟？陈虻经常挂在嘴边的叮嘱：你的视角有多宽，你观察一个事物的深度就有多深。当你的思维打开的时候，你就走向成熟。\n我们相信教育学的一个原理：自我教育所取得的效果胜于他人枯燥乏味的说教。\n你的片子不是只给我看，你是给所有的观众看的，你能把所有的理由解释给他们吗？那之后，我学会了不再给自己的错误寻找借口。\n为什么不饶人，就因为他接受信息的方式是错误的，并不是因为他不尊重我，而是因为他在听我说话的时候，老在寻找我的信息跟他的信息相同的部分，而不是寻找我的信息跟他的信息不同的部分。\n我感觉我们应该像他一样，多思考多输出，对事业百分百的投入。\n","permalink":"https://www.liuchang0812.com/posts/read/2025-03-chenmang/","summary":"东方时空制片人陈虻的一些话和思考","title":"2025 03 读书分享:不要因为走得太远而忘记为什么出发"},{"content":"单伟健博士的自传，内容主要包含了他从小在北京生活上学，到文革闹革命的见闻，然后到内蒙古戈壁劳作。之后以工农兵身份到对外贸易大学读书，毕业之后到美国读博任教的经历。\n时刻准备着，浪费时间就是对自己的谋杀。当机会来临的时候要抓住，不能因为没有准备而错失机会。 干一行爱一行，任何事情都要做好。 遇到问题多思考，从目标和对方角度考虑怎么解决。 深入群众和所有人搞好关系，人脉非常重要。 建议读英文或者繁体版本。简体版本删减了太多内容。\n","permalink":"https://www.liuchang0812.com/posts/read/2025-03-out-of-the-gobi/","summary":"从戈壁滩走到美国，我是如何成为沃顿商学院教授的","title":"2025 03 读书分享:走出戈壁"},{"content":"单伟健讲述收购韩国第一银行的故事，全文可分为收购银行、改造银行和出售银行三个部分。其中第一部分篇幅最长，详细讲述了长达两年的谈判过程。由于作者有记录日记的习惯，文中对细节的描写尤为具体。\n通过这个故事可以学习金融领域相关知识，了解专业谈判技巧，以及如何将破产银行改造为优质资产的操作方法。\n其中若干细节颇具启示意义：\n单博士无论工作多繁忙，始终坚持每日晨跑10公里 国有资产处置官员承受巨大舆论压力，宁愿牺牲部分收益也要平息民族主义情绪。为规避未来追责风险，主动要求引入审查机制 人性立场难免影响叙事，作者存在选择性美化倾向。例如书中强调主动捐赠数千万善举，却隐去了此举实为平息因避税问题引发的民众不满这一背景事实 ","permalink":"https://www.liuchang0812.com/posts/read/2025-03-money-game/","summary":"想知道怎么收购一家银行吗？","title":"2025 03 读书分享:金钱博弈"},{"content":"偶然在微信读书上看到这本书，作者是写了红色的起点那本书的叶永烈。按照时间顺序介绍了陈云的一生，写的还不错，很推荐。\n总的来说，前半部分比较精彩一些，了解很多革命早期的事迹。后半部分很多是已经知道的事情。\n","permalink":"https://www.liuchang0812.com/posts/read/2024-11-chen-yun/","summary":"叶永烈著《陈云传》","title":"2024 11 读书分享:陈云传"},{"content":"LSP 是 VSCode 定义的一个语言无关的协议，提供代码解析补全等功能。本文以 leveldb 为例，介绍一下怎么通过 LSP 来更方便的阅读代码。\n首先，我们需要下载代码，并生成 compile_commands.json 文件，clangd 会通过这个文件知道整个项目是如何编译的。\ngit clone https://github.com/google/leveldb.git cd leveldb/ git submodule update --init mkdir build cd build cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=1 .. 然后，我们就可以使用 VSCode 来阅读代码了，将鼠标放在变量名上，可以很容易的看到定义。可以任意的跳转定义和实现。可以方便的看到有哪些子类，有哪些地方调用了函数接口。\n也可以方便的查看 Call Hierarchy 和 Type Hierarchy。\nCall Hierarchy 有哪些地方调用了这个方法 Type Hierarchy 有哪些子类 可以很方便的看到传参的含义。\n","permalink":"https://www.liuchang0812.com/posts/tech/read-code-vscode/clangd/","summary":"使用 LSP 和 clangd 高效阅读 C++ 源码","title":"现代化的源码阅读方法"},{"content":"使用状态机思路解决一个并行问题。\n题目可以描述为：进程A每轮循环产生一个 H，进程 B 每轮循环产生一个 O，需要保证每产生 3 个元素时都由 2 个 H 和 1 个 O 组成。\n朴素的解法：思考哪些数据需要放到临界区，比如产生了几个 H 和 几个 O，当自己的职责完成后，检查是否 H20 了，如果未满足就 wait 或者跳出（只生产一个 H 时）。当满足 H20 时就激活信号量，重置状态。\n上面的代码写起来还是比较繁琐的，考虑一下用一个状态机来描述这个问题。状态机如下，当状态为 -1 时，线程应该被阻塞。整个程序只需要纪录一个当前状态，代码简单逻辑清晰。\nState H O 0 {} 1 4 1 H 3 2 2 HO 0 -1 3 HH -1 0 4 O 2 -1 ","permalink":"https://www.liuchang0812.com/posts/tech/leetcode/state-machine-in-concurrency/","summary":"使用状态机思路解决 H2O 构建问题","title":"并发编程中的状态机"},{"content":"最近主要读了《民主的细节》《芯片战争》和新出的《Elon Musk》几本书。《芯片战争》是在飞机上快速翻了一遍。《民主的细节》是因为前段时间《巨变第二天》特别火，国内还买不到，所以找了一下作者其它著作。《Elon Musk》则是在公司读书活动上白嫖的。\n芯片战争 推荐大家读一读，可以快速浏览了解到芯片行业的发展过程。一是可以浅浅的了解到芯片技术和难点，现在的光刻机的难度相当“在地球上用激光打到月球上的一枚硬币”、“制作一个放大到地球大小也没有大坑洼的透镜”。二是了解芯片发展过程中各家公司和中美苏的发展历史和取舍，这儿中文版有删减。三是台湾台积电的芯片代工，有点儿像是计算机分层。在台积电之前如果要生产芯片要自己搞整个完整的流程，台积电则是专注在生产这一层，其它公司专注在设计芯片，把整个芯片流程解耦了。如果现在你要创业搞芯片，可以不用再自己建厂、购买光刻机、培训员工等。\nElon Musk 新出的一本马斯克传，挺有意思的。天才都是偏执的，故事的流程都是：提出一个不可能的目标，定一个不可能的deadline，你不听musk的就开除，然后 musk 深入一线对每个细节都关注，然后取得巨大的成功。\n民主的细节 期望很高，实际上很失望。以为作者是高校教授，这本书会是偏理论引用详实的那类。实际上有点儿故事会，套路都是：美国最近发生了一件有意思的事，在美国是怎么处理的，如果在中国会怎么样，然后总结升华一下。\n","permalink":"https://www.liuchang0812.com/posts/read/2023-11-reading/","summary":"《民主的细节》《芯片战争》《Elon Musk》","title":"2023 11 读书分享:民主的细节、芯片战争、Elon Musk"},{"content":"这本书主要包含两个部分，第一个部分介绍了清代行政体系下几个主要角色的方方面面，包括职责、如何认命监管、怎么获取陋规，第二个部分介绍清朝司法税务等主要部门的运行机制。非常推荐。\n前半本书阅读下来，感想就是“百姓苦啊，只要和官府打交道就要被所有角色剥削”。统治阶级也知道这些陋规的存在，但是默认了这些行为，甚至将其中一些陋规合法化，不然无法维持整个行政体系。\n司法体系\n州县官只能使用民事案件以及不超过笞杖或枷号的轻微刑事案件。判决不需要上级批准但是需要定期上报。 如果有错判，州县官要遭受同样的罪责 治安与保甲制度，发动群众与连坐制。\n辖区内的民户组织成牌（十户）、甲（百户）和保（千户）等基本治安单位，并指定牌头、甲长、保正或保长。[1]州县官每年会向每户人家签发一个门牌，上面列出户主的姓名、年龄、职业和该户其他成员的姓名，包括亲戚和仆婢。[2]只要家中有人员进出变动，户主就要向甲长汇报。甲长有责任在保甲簿中予以登记，并修正门牌。[3]通常，保甲簿一式两份，一份由甲长保存，另一份由州县官保存。甲乙两簿定期交换：甲簿由甲长根据甲内实际人口的变动修正后，呈交给州县官，州县官就将乙簿交还给甲长由其作相应改动，如此循环。这种方式确保了保甲记录的不断更新。[4]\n保甲制度同时适用于乡村和州城县城，所有居民都包括在保甲组织内，包括无业者、流配人犯、娼妓和其他受法律制裁者。[5]保甲制的基本功能，是要建立起缉查违法，特别是缉查强盗、土匪的治安组织网络。[6]有些州县官还借保甲制以推进道德教化之功效。[7]保甲制度背后的深层理念是：每个人的行动都难以逃过邻里乡亲之耳目；若将邻里居民组织起来，官方掌握所有民户登记资料，则陌生人及违法者必定难以在守法居民中隐藏。\n尽管设立常平仓的目的是造福穷人，但实际上它并未给穷人带来福利。首先，由于粮仓设在州城县城，居住偏远的乡民常常享受不到好处。 尽管法律有禁令，[11]但儒户、衙役和粮行老板仍常常勾结书吏，假造名籍大量购买官米，从其低廉的价格中获利。[12]粮仓书吏和衙役常常对到官仓购米的百姓勒索钱财，或者要求他们超量返还从官仓借去的粮食。[13]为了将陈年粮食清仓，有的州县官常强迫百姓购买陈粮，即使他们并不需要。[14]百姓更有一种负担，即州县官常常以低于市场的价格向本州县百姓购粮，并要售粮者自己将粮食从乡村运送到官仓。[15]因此，朝廷曾发布一条规定：补充官仓的粮食必须从邻县购置；只有本县和邻近州县之间没有水运的情况下，州县官才可以在自己辖区内购粮。\n有时候政策是好的，执行起来却问题很多。\n根据曾任县官的方大湜的经验，灾害勘查的过程往往充满罪恶的勾当。如果将这一事务交由书吏、保甲长来办理，他们就会从事各种贪污活动。[41]如果委托给士绅，又容易出现徇私舞弊的情况。同时，州县官亲自到各家各户查访又极端困难。[42]王凤生认为最好的办法是由村长登记受灾人口，由士绅核查，再由专员作进一步审查。\n中国士绅的一个重要特点是：他们是唯一能合法地代表当地居民社群与官吏共商地方事务、参与治理过程的群体。这一特权从未扩展到其他任何社群和组织。\n具备进入特权阶层的条件，与特权身份实际获得，二者之间是有差距的。财富和田产本身，不是士绅身份的充分条件。庶民地主，不论拥有多少土地，也不属于士绅群体。“学绅”既不属于统治阶层，也不属于被统治阶层，他们属于一个中间阶级。[21]他们并未加入正式的政府，但却享有很高的威望、特权和统治阶级权力——这一事实将他们作为精英与普通大众区别开来。作为官僚集团的潜在候补成员，他们也可称作潜在的统治阶级。 官绅不在当地司法管辖权之下，也不受常规司法程序的约束。未经皇帝的允许，官员不得受审讯和判决。 只有财富与政治权力联结起来时，人们才能确保其自身和家庭的安宁。[21]这有助于解释为何人们渴望获得功名和当官。 作为一个特权阶层，他们渴望维持现状，抵制任何可能危害既定社会秩序的力量。地方防务，这样一种需要强有力的权威和财力支撑的任务，自然就落到了士绅肩上，因为他们为地方百姓所尊敬和追随并可以接触政府官员。 地方官吏既然不能跟士绅争辩附加费的合法性，又无力确立一个更高的折算率，就只好根据惯例按较低附加费率向士绅征税。为了弥补征税成本和衙门其他开支，官员只好将税收负担转嫁到不能据法抗争、无力保护自己的普通百姓头上。 顾炎武才认定，官绅、学绅、书吏、衙役这些豁免徭役的群体，正是引起百姓苦难的祸首。他认为，只有“废生员”才能缓解百姓的痛苦。 学而优则仕 ","permalink":"https://www.liuchang0812.com/posts/read/2023-07-reading/","summary":"《清代地方政府》了解清朝行政体系运作机制","title":"2023 07 读书分享：清代地方政府"},{"content":"强烈推荐，书的排版很好，翻译的也特别好。比较有意思的是前半部分，介绍了明代的世袭军户制度下，人们从想办法减少服役代价，到利用制度来进行套利的方法，以及制度对人们生活文化的影响。\n这本书是外国人写的，还有部分被删减的内容。有兴趣的可以看豆瓣上网友的整理。\n这本书介绍了群众面对制度时的几大策略：\n“优化处境”（strategies of optimization）：轮替、集中、补偿、代役（集中策略的延伸）。 “近水楼台”（strategies of proximity）：卫所军官和士兵利用自己在军事体制中的特殊地位参与非法贸易，浑水摸鱼。 “制度套利”（strategies of regulatory arbitrage）：被调入军屯的屯军擅长运用套利策略，借由军田与民田的差异渔利。 “诉诸先例”（strategies of precedent）：清初军户如何试图维护自己在明朝体制中享有的特权，或出于利益考量为旧体制招魂。（308-309） ","permalink":"https://www.liuchang0812.com/posts/read/2023-06-reading/","summary":"《被统治的艺术》明代军户制度下百姓的生存策略","title":"2023 06 读书分享：被统治的艺术"},{"content":"《城乡中国》豆瓣 4/5 分，一本关于中国土地财政的书，介绍了从建国以后关于土地的法律法规变化以及各方尝试。内容挺有意思，但是因为是文章合订本，内容有重复，逻辑性不太流畅。一些有意思的点： 关于自由迁徙：中国第一版的宪法是有写公民有自由迁徙的权力，在文化大革命的时候又被删了。教员在最开始的时候是不同意宪法中有自由迁徙的。 关于土地市场化：土地不许买卖 \u0026ndash;\u0026gt; 土地可以依法转让，但是要国务院立法。\u0026ndash;\u0026gt;国务院规定城市土地国有，可以流转。农村土地归集体，却一直不立法。\u0026ndash;\u0026gt; 各地实点实验：挂钩、地票等。 \u0026ndash;\u0026gt; 城市扩市或者征地。 只有国有土地可以流转。在超额土地利益面前，不再是人人平等。农民无法享受这一波红利。深圳是100%土地城市化国有化，也是第一个学习香港立法拍卖土地的。在宪法修改时，曾打算所有土地国有，为了减小影响，后面修改为“城市土地一律国有，农村土地归集体所有”。 作者认为解决问题的方法是：还权赋能，农地入市。但我认为这很难实现，土地财政已经绑架了太多人太多东西。如果最开始就农地入市也许我们可以像欧美一样人人住上大 house，但是历史没有假如。 《王氏之死》豆瓣 3/5 分，漫长的余生中推荐的一本书，但是读来实在没什么意思，内容也比较少。可能是我的能力问题，没有读到精髓。 ","permalink":"https://www.liuchang0812.com/posts/read/2023-05-reading/","summary":"《城乡中国》《王氏之死》","title":"2023 05 读书分享：城乡中国、王氏之死"},{"content":"漫长的余生 书名不好，书很不错。这种书名放在面前都可能不会被注意到。 作者希望用宫女王钟儿作为线索，介绍北魏的一段历史。但是实际读起来，感觉意义不大，不如直述。 之前对魏晋南北朝这段历史了解不多，读这本书还是比较吃力（人物名字太相似），但是北魏的历史还挺有意思。搜了一下国内有一部电视剧叫 胡笳汉月，可惜没有过审，被剪成了几集历史纪录片。 需要把主要人物的关系图整理一下，才能更好理解。 ^^子贵母死^^ 的制度真是残忍，本来是为了避免外戚乱权，却被几任皇太后利用来维持自己的地位。 %%{init: {'theme':'neutral'}}%% flowchart TD XiaoWD[孝文帝] FHH[冯皇后] CTH[常太后] WCD[文成帝] XianWD[献文帝] DFHH[大冯皇后] XFHH[小冯皇后] XWD[宣武帝] GZR[高照容] YX[元恂] subgraph 皇帝 WCD==长子==\u003eXianWD==长子==\u003eXiaoWD==次子==\u003eXWD XiaoWD==长子==\u003eYX end subgraph 皇后 CTH--选立--\u003eFHH FHH--侄女--\u003eDFHH FHH--侄女--\u003eXFHH DFHH--杀死--\u003eGZR end CTH--乳母--\u003eWCD FHH--乳母--\u003eXianWD FHH--杀死生母从小抚养--\u003eXiaoWD XiaoWD--皇后--\u003eDFHH XiaoWD--皇后--\u003eXFHH GZR--生母--\u003eXWD DFHH--抚养--\u003eXWD XFHH--抚养--\u003eYX 父母的语言 这本书的核心观点是小朋友3岁前接受到语言词汇对于智力发育有很大的影响。按照作者统计，经济差异大的家庭之间有3 kw的单词数差异。\n文章提到一个4T原则，还是很有道理的\nTune In 共情 Talk More 充分交流 Take Turns 交替交流 Turn off 关闭电子设备 书的逻辑性不太认可，表述也一般，可能和翻译有关，一般推荐\n","permalink":"https://www.liuchang0812.com/posts/read/2023-04-reading/","summary":"《漫长的余生》《父母的语言》","title":"2023 04 读书分享：漫长的余生、父母的语言"},{"content":"小镇喧嚣：一个乡镇政治运作的演绎与阐释 推荐，华科大教授写的一本书，记录了在小镇调查的一年半期间遇到的事情，主要包括：镇政府如何处理上级检查，乡镇村干部如何收农业税，如何处理各种农村冲突上访等。\n文风不错，像读小说一样引人入胜。同时引用详细，可以学到大量不知道的知识。\n美丽新世界 一本反乌托邦世界的书，其中未来世界的设定很有意思。\n人类还通过基因工程被改造成几个等级，以便从事不同的工作。低等级的人类从事重复劳动，而他们因为智商低下，像动物一样被劳役而不会反抗。而高等级的人类，他们从小在睡眠中被催眠教育，不相信上帝，不相信爱情。人是通过试管培育的，没有父亲，没有母亲。“每个人都属于彼此。”所以男人可以和任何一个女性做爱，女性也可以和任何男性交往。他们没有嫉妒。没有排他的占有欲。A片高级到只要看的时候手扶把手，可以通过电磁波把感官感受直接作用于人体。而这些方式当然并不能消除人类所有的欲望而使人免于痛苦。当人有烦恼的时候，可以吃点“唆麻”，一种对人体无害的毒品。然后人就忘记烦恼，无忧无虑了。\n失去的三十年 介绍日本广场协定泡沫破裂相关历史和知识。这本书篇幅较小，内容也较少。看完之后留下的有印象的内容很少。后面有空再认真看一遍吧。\n","permalink":"https://www.liuchang0812.com/posts/read/2023-03-reading/","summary":"《小镇喧嚣》《美丽新世界》《失去的三十年》","title":"2023 03 读书分享:小镇喧嚣、美丽新世界、失去的三十年"},{"content":" 最近在咸鱼上入了一个 kindle oasis，体验比之前的 kindle paperwhite 好太多了，最近买得最值的东西了。争取可以多看书多写文字分享，锻炼一下自己。\n《置身事内》介绍中国经济相关知识 个人觉的非常不错的书，值得 5 星推荐。之前在微信读书上看过，这几天又抽空在 kindle oasis 上看了一遍，还是收获很大。\n前段部分介绍了中国这几十年来经济发展过程与其中遇到的问题与改革方法，比较体系化的介绍了为什么从“财政包干”到“分税制”改革，再到“国税地税合并”和“房地产”。也介绍了中国政府的运作方式。也介绍了“京东方”和“光伏“产业发展的历史。 后段部分宏观分析了债务、工业化、国际贸易等，相对我就不太感兴趣了。\n作者文笔十分流畅，引用清晰，而且每章都推荐了很多相关的书。\n《永久记录》斯诺登传记 斯诺登自己写的传记，介绍了小时候的成长经历，在美国国安局的工作经历，以及后来在 HK 发生的事情。\n3 星推荐吧。作者的一些思考还有些意思。\n《他改变了中国》江泽民传记 4 星推荐。江主席的人生智慧。值的认真读一下，可以了解到很多历史细节。\n","permalink":"https://www.liuchang0812.com/posts/read/2023-02-reading/","summary":"《置身事内》《永久记录》《他改变了中国》","title":"2023 02 读书分享:置身事内、永久记录、他改变了中国"},{"content":"libco 协程，被分类到非对称协程。分类的方法是：\n对称协程（典型的如 golang 的 goroutine），一个协程 yield 后，执行机会不会直接返还到调用者，而是调度器来决定唤起哪个协程。 非对称协程（例如 libco ），一个协程 yield 后，会返还到调用者，继续执行调用者的函数。 非对称在于程序控制流转移到被调协程时使用的是 call/resume 操作，而当被调协程让出 CPU 时使用的却是 return/yield 操作。此外，协程间的地位也不对等，caller 与 callee 关系是确定的，不可更改的，非对称协程只能返回最初调用它的协程。\nhttps://zhuanlan.zhihu.com/p/51078499\n在 libco 的实现中，每个线程会有一个 stack 来维护当前的协程列表，调用 co_resume 则会压入一个协程，调用 co_yield 则会弹出一个协程（实际的实现是栈顶指针的加减）。\n所以，在实际使用过程中，如果涉及到复杂场景，需要用到 co_yield 来自己调度 libco 的协程。那么怎么来实现呢，有没有什么套路。我们可以参考这个自带例子来学习一下。\n因为需要自己调度协程，所以一般要把协程指针和对应任务信息封装到一个结构体中，同时使用一个 stack/queue 保存所有的协程（因为一个协程 yield 之后就找不到了，没办法自动继续执行）。\nstruct task_t // 一个任务结构体 { stCoRoutine_t *co; // 对应的协程指针 int fd; // 协程负责任务的参数 }; static stack\u0026lt;task_t*\u0026gt; g_readwrite; // 开一个全局变量来保存所有的任务 为了方便理解，可以先忽略例子中的多进程部分代码。代码先创建了若干个 readwrite_routine协程\nfor(int i=0;i\u0026lt;cnt;i++) { task_t * task = (task_t*)calloc( 1,sizeof(task_t) ); task-\u0026gt;fd = -1; // 特殊值 co_create( \u0026amp;(task-\u0026gt;co),NULL,readwrite_routine,task ); co_resume( task-\u0026gt;co ); // 压到 stack 中开始执行，跳转到下面的函数 } static void *readwrite_routine( void *arg ) { co_enable_hook_sys(); // hook read/write 等io调用走协程实现 task_t *co = (task_t*)arg; char buf[ 1024 * 16 ]; for(;;) { if( -1 == co-\u0026gt;fd ) // 第一次进来是 -1 特殊值，将 task 保存到 g_readwrite { g_readwrite.push( co ); co_yield_ct(); // 让出 cpu 到调用者，也就是主线程，继续创建协程。 } // 然后会进入到 accept_routine continue; int fd = co-\u0026gt;fd; // 从 accept_routine 切换回来，这个时候 fd 有值了 co-\u0026gt;fd = -1; // 标记为特殊值，下次循环会 yield 出去 for(;;) { // 任务逻辑 struct pollfd pf = { 0 }; pf.fd = fd; pf.events = (POLLIN|POLLERR|POLLHUP); co_poll( co_get_epoll_ct(),\u0026amp;pf,1,1000); int ret = read( fd,buf,sizeof(buf) ); if( ret \u0026gt; 0 ) { ret = write( fd,buf,ret ); } if( ret \u0026gt; 0 || ( -1 == ret \u0026amp;\u0026amp; EAGAIN == errno ) ) { continue; } close( fd ); break; } } return 0; } static void *accept_routine( void * ) { co_enable_hook_sys(); for(;;) { if( g_readwrite.empty() ) // g_readwrite 为空时，等待1s { struct pollfd pf = { 0 }; pf.fd = -1; poll( \u0026amp;pf,1,1000); continue; } struct sockaddr_in addr; //maybe sockaddr_un; memset( \u0026amp;addr,0,sizeof(addr) ); socklen_t len = sizeof(addr); int fd = co_accept(g_listen_fd, (struct sockaddr *)\u0026amp;addr, \u0026amp;len); if( fd \u0026lt; 0 ) { struct pollfd pf = { 0 }; pf.fd = g_listen_fd; pf.events = (POLLIN|POLLERR|POLLHUP); co_poll( co_get_epoll_ct(),\u0026amp;pf,1,1000 ); // co_accept/co_poll注册回调，在有数据的时候swap回来，然后让出 cpu，执行 co_eventloop continue; } if( g_readwrite.empty() ) // double check { close( fd ); continue; } SetNonBlock( fd ); task_t *co = g_readwrite.top(); // 取一个协程，分配这个 accept 的 fd co-\u0026gt;fd = fd; g_readwrite.pop(); co_resume( co-\u0026gt;co ); // 切换到改协程，继续执行 readwrite_routine } return 0; } 总结一下 使用 libco 自己调度协程的实现模式有：\n用一个全局队列保存所有的任务执行协程； 使用 task 结构体保存协程指针和任务参数； 任务执行协程初始化后压到协程队列，让出 cpu 给调用者； 任务分发协程在没有可用协程时（协程队列为空），等待任务协程空闲。有任务时，更新任务参数后唤醒执行协程。 ","permalink":"https://www.liuchang0812.com/posts/tech/os/libco-usage/","summary":"libco 非对称协程的使用模式和调度方法","title":"libco usage"},{"content":"Paxos 协议与工程实现 写在前面，我没有完整实现过 Paxos 协议，不敢保证下面描述的内容完全正确。本文主要是学习的笔记，如果有错误，十分欢迎指出，大家一起讨论学习。\n本文所有内容都是参考 PaxosStore 论文 《PaxosStore: High-availability Storage Made Practical in WeChat》\n概念定义 为了后续方便描述，我们先定义会用到的概念\nProposal 提议，包含提议号和提议值； Prepare 第一阶段 Proposer 发出的请求，包含一个提议号； Promise 第一阶段 Proposer 回应的消息，包含一个提议号和一个（如果有）已经 Accepted 的最大提仪； Accept 第二阶段 Proposer 发出的请求，包含一个提议号和一个提议值； Accepted 第二阶段 Proposer 回应的消息，包含一个提议号。也表示一个提议被一个该 Proposer 接受； Chosen 代表一个提议被大多数的 Proposer 接受，不会再发生改变； Proposer 提议成员； Acceptor 发送 Accepted 消息的成员； Learner 学习者，不参与 Paxos 投票过程。 与可以用代码语言描述，参考 链接\n// Prepare 请求，包含一个提议号 struct Prepare { int n; }; // 在收到大多数的 Promised 请求后，发出的 Accept 请求，包含一个提仪号以及一个值。 // 这个值是 Promised 中最大提议号的值，如果所有 promised 都没有返回值，则可以自己提出任意值。 // 对应到工程实现上，则代表这个位置已经被占了，可以再起一轮新 paxos struct Accept { int n; void *value; }; // n 承诺不 accept 小于 n 的 accept 请求，返回当时最大提议号对应的值。 struct Promised { int n; Accept *proposal = nullptr; }; // 如果满足承诺，返回最大的提议号 struct Accepted { int n; }; // paxos 成员会在内存中纪录的值，包括最大的提议号，以及对应的值。 class Acceptor { int last_n = 0; Accept *proposal = nullptr; }; Basic Paxos 协议 Basic Paxos 是理论上的最基础的一致性算法，作用是：多个（奇数）成员确定唯一一个值。\n算法分为两轮，第一轮 Prepare 请求会得到承诺后续不通过小于本次 Prepare.n 的提议，同时返回自己已经 accepted 的最大提议。第二轮 Accept 请求会带上上一轮收到的最大提议值（如果没有，则可以自己提出），每个 Acceptor 在不违背承诺的情况下更新本地状态。\n一个提仪一旦被大多数结果 accepted，就会被认为是 chosen。对于一个值来说，accepted 还是可以变的，chosen 的永远不会变。一组经典的 paxos 实例只能确定（chosen）一个值。\n算法的详细描述可以参考论文：\nPhase 1.\nA proposer selects a proposal number n and sends a prepare request with number n to a majority of acceptors.\nIf an acceptor receives a prepare request with number n greater than that of any prepare request to which it has already responded, then it responds to the request with a promise not to accept any more proposals numbered less than n and with the highest-numbered proposal (if any) that it has accepted.\nPhase 2.\nIf the proposer receives a response to its prepare requests (numbered n) from a majority of acceptors, then it sends an accept request to each of those acceptors for a proposal numbered n with a value v, where v is the value of the highest-numbered proposal among the responses, or is any value if the responses reported no proposals.\nIf an acceptor receives an accept request for a proposal numbered n, it accepts the proposal unless it has already responded to a prepare request having a number greater than n.\n注意细节：\nAccept 请求中的 value 是一阶段返回所有 promised 中 n 最大的那个值。是 promised→proposal.n 的 n，而不是 promised.n acceptor 上 accept 值还是会被修改的。 在提议被大多数通过的一瞬间，这个值就确定下来了，再也不会被修改。 对于证明的思路是这么一种思路：证明一个值 chosen 不会被修改，可以通过加强的方式。如果一个大于当前提仪号并且值不同的提仪，不会被发出。chosen 的值自然就不会被修改。\nMulti Paxos 实现方法 可以看到，Basic Paxos 算法只能确定一个值，同时要走两轮流程。为了在真实系统上实际使用起来，还需要做一些修改优化。\n我们可以在 Basic Paxos 上增加一个 Entry ID 的维度，每个 Entry 保存一个值。同时，可以在第 i 个 Entry 中携带上第 i+1 个 Entry 的 Prepare 信息：当 $E_i$ 被 chosen 时，同时认为 $E_i+1$ 已经完成了 prepare 流程。\n工程实现上的问题 论文只描述了 Paxos 算法的流程和证明，在实际实现上，还有很多细节要处理，例如怎么 CatchUp、怎么 GetALL以及一些细节的问题。\n写读读问题 写读读的问题场景：假设三机日志都commit到了Entry 100，然后机器 A执行 Entry 101 的二轮过程然后挂掉。这个时候会读到 100 的值。然后机器 A 恢复同步状态到 BC，后续就读到了 Entry 101。\n重复执行问题 重复执行的问题场景：机器 A 收到一个写请求，在执行完 Paxos 后被 chosen，然后发送响应给客户端。这个响应可能因为网络原因未发到或者超时。然后客户端超时后重发请求到机器 B。机器 B 重新跑一次 Paxos 过程，然后回复客户端。这儿更新过程就会执行两次，如果是有状态的更新就会有问题。\n所以要让请求幂等，方法就是在请求上带上 request ID， svr 端检查 request ID 。\nThe request ID is generated by the client and sent together with the write request, and checked by the PaxosStore node to detect potential duplication of actual request handling.\nPlogKV 实现问题 文章同时提到了一个 PaxosLog for KV Data，可以优化掉 DB 部分的成本。那么正常的plog存储的key应该是entityid和entryid？怎么用key来查询？\n答案是只维护两个entry，一个最新chosen，一个pending。每个 key 都是一个 paxos 实例。\n参考 https://sf-zhou.github.io/paxos/paxos_store_03_consensus.html http://www.vldb.org/pvldb/vol10/p1730-lin.pdf ","permalink":"https://www.liuchang0812.com/posts/tech/os/paxos-note/","summary":"Paxos 协议详解与工程实践","title":"Paxos Algorithm Note"},{"content":"cgroup 全称是 control group，是 linux 下的一个内核模块，用来控制进程的系统资源使用。例如可以限制进程 cpu 使用量、内存使用量等。比如知名开源软件 docker 就是基于 cgroup 来限制容器资源使用，使用 namespace 隔离进程空间。\ncgroup 分为 v1 和 v2 两个版本。常用的子系统有：\ncpu/cpuset/cpuacct：限制和统计 cpu 的用量 memory：限制内存的用量 blkio：限制块设备的用量，但是只能限制 direct io 使用方式 cgroup 基于 linux vfs 技术，将 cgroup 映射到一个目录。系统管理员通过在目录下创建文件的方式来使用 cgroup。默认情况下，cgroup 映射的目录为 /sys/fs/cgroup ，该目录下每个目录对应一个子系统。系统管理员可以在子系统目录中新建树状目录来设置 cgroup 限制，例如 /sys/fs/cgroup/cpu/g1 代表一类进程限制。\n➜ ~ ls /sys/fs/cgroup blkio cpu cpuacct cpu,cpuacct cpuset devices freezer hugetlb memory net_cls oom perf_event pids systemd 除了使用 /sys/fs/cgroup ，还可以通过 cgcreate 、 cgexec 等命令来使用 cgroup。例如\n# 使用 /sys/fs/cgroup/cpu/test_cpu 来限制 ./test 进程运行 cgexec -g cpu:test_cpu ./test ","permalink":"https://www.liuchang0812.com/posts/tech/os/cgroup/","summary":"Linux cgroup 进程资源控制使用指南","title":"cgroup usage"},{"content":" 我们以 C++11 的 API 接口定义来描述\n大家在编写多线程类的程序时，会用到信号量 condition_variable，有没有疑惑过为什么 cv 这类接口，在调用 wait/notify 时候还需要用一个 mutex。\n为什么 cv.wait() 需要用 mutex 保护？ 常见的 cv 代码实现类似下方，包含三个部分：检查条件是否满足；如果不满足等待到满足；等待到满足后执行逻辑。\nstd::unique_lock\u0026lt;std::mutex\u0026gt; lock(cv_m); while (!cond_ok()) { // 1. 检查条件是否满足 wait(lock); // 2. 等待信号 } // do somethings with cond // 3. 执行逻辑 如果没有一个锁保护这三个部分，会出现两种情况：\n在第一部分检查条件不满足，准备进行第二部分 wait信号时，另一个线程达到了信号条件并 signal ，然后执行到 wait 。这个时候 wiat 就永远挂在这儿了。 在第二部分执行完成后，认为已经达到条件，准备执行第三部分的业务逻辑。另一个线程修改了条件。第三部分执行的假设是条件已经满足，违反了假设，业务逻辑可能会有问题。 所以一般会通过一个 mutex 将上述三个部分看起一个原子操作，将检查条件是否完成与等待信号量同时执行。其它线程如果 signal 信号，一定是在检查条件之前或者wait之后。\n附录 lock-and-condition-variable cppreference ","permalink":"https://www.liuchang0812.com/posts/tech/os/why-conv-need-a-mutex/","summary":"理解条件变量 wait/notify 为什么需要 mutex 保护","title":"Why Does Conv Need a Mutex"},{"content":"书名：1984 政治小说，推荐指数 4 颗星\n小说虚构了一个极权社会，介绍了为真理部工作的外党成员温斯顿的故事。在极权社会下，到处都有电屏的监视。人们每天还要进行仇恨会的活动。对于不认同老大哥统治的思想有“问题”的人，会被思想警察完全从社会上抹去。\n主人公为真理部工作，工作内容是篡改历史，抹去被消失人的纪录。小说中主要分为两部分：一部分是认识女主，和女主发生的故事。另一部分则是被思想警察钓鱼执法，被惨烈的思想改造。\n书名：大逃港 政治向的报告文学，推荐指数 4 颗星\n这本书主要介绍了在建国后深圳人民群众逃港的故事。稍微的有点儿故事会写法。人民不管姓资还是姓社，只关心能不能吃饱肚子过上好日子，于是用脚投票，冒着生命危险去逃港。在改革开放后，则大量减少了逃港行为。\n书名：风格的要素 关于英语写作的小册子，推荐指数 2 颗星\n","permalink":"https://www.liuchang0812.com/posts/read/2022-05-reading/","summary":"《1984》《大逃港》《风格的要素》","title":"2022 05 读书分享:1984、大逃港、风格的要素"},{"content":"记忆化搜索，刚好卡过去\n执行用时：1964 ms, 在所有 C++ 提交中击败了 5.08% 的用户\nint mem[100][100][100][100]; class Solution { public: // 0 unknow // 1 true // 2 false bool dfs(const vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; grid, int x1, int y1, int x2, int y2) { if (x1 \u0026gt;= grid.size() || x2 \u0026gt;= grid.size() || y1\u0026gt;=grid[0].size() || y2 \u0026lt; 0 || x2 \u0026lt; 0 || x1 \u0026gt; x2 || y1 \u0026gt; y2) return false; if ((x2 - x1 + y2 - y1)%2==0) return false; if (mem[x1][y1][x2][y2] != 0) { return mem[x1][y1][x2][y2] == 1; } if ( x2 - x1 + y2 - y1 == 1 \u0026amp;\u0026amp; grid[x1][y1] == \u0026#39;(\u0026#39; \u0026amp;\u0026amp; grid[x2][y2] == \u0026#39;)\u0026#39;) { mem[x1][y1][x2][y2] = 1; return true; } if (grid[x1][y1] == \u0026#39;(\u0026#39; \u0026amp;\u0026amp; grid[x2][y2] == \u0026#39;)\u0026#39;){ bool tmp = dfs(grid, x1+1, y1, x2-1, y2) || dfs(grid, x1+1, y1, x2, y2-1) || dfs(grid, x1, y1+1, x2-1, y2) || dfs(grid, x1, y1+1, x2, y2-1); if (tmp) { mem[x1][y1][x2][y2] = 1; return true; } for (int i=x1; i\u0026lt;=x2; ++i) for (int j=y1; j\u0026lt;=y2; ++j) { if (i == x1 \u0026amp;\u0026amp; j==y1) continue; if (i == x2 \u0026amp;\u0026amp; j==y2) continue; if ((dfs(grid, x1, y1, i, j) \u0026amp;\u0026amp; dfs(grid, i, j+1, x2, y2))) { mem[x1][y1][x2][y2] = 1; return true; } if (dfs(grid, x1, y1, i, j) \u0026amp;\u0026amp; dfs(grid, i+1, j, x2, y2)) { mem[x1][y1][x2][y2] = 1; return true; } } mem[x1][y1][x2][y2] = 2; return false; } else { mem[x1][y1][x2][y2] = 2; return false; } } bool hasValidPath(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; grid) { int row = grid.size(); int col = grid[0].size(); if ((row + col)%2==0) return false; if ( grid[0][0] == \u0026#39;)\u0026#39; || grid[row - 1][col - 1] == \u0026#39;(\u0026#39;) return false; memset(mem, 0, sizeof mem); return dfs(grid, 0, 0, row-1, col -1); } }; 题解里面有一个写法很好，可以学习一下\nclass Solution { public: bool hasValidPath(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; \u0026amp;grid) { int m = grid.size(), n = grid[0].size(); if ((m + n) % 2 == 0 || grid[0][0] == \u0026#39;)\u0026#39; || grid[m - 1][n - 1] == \u0026#39;(\u0026#39;) return false; // 剪枝 bool vis[m][n][(m + n + 1) / 2]; memset(vis, 0, sizeof(vis)); function\u0026lt;bool(int, int, int)\u0026gt; dfs = [\u0026amp;](int x, int y, int c) -\u0026gt; bool { if (c \u0026gt; m - x + n - y - 1) return false; // 剪枝：即使后面都是 \u0026#39;)\u0026#39; 也不能将 c 减为 0 if (x == m - 1 \u0026amp;\u0026amp; y == n - 1) return c == 1; // 终点一定是 \u0026#39;)\u0026#39; if (vis[x][y][c]) return false; // 重复访问 vis[x][y][c] = true; c += grid[x][y] == \u0026#39;(\u0026#39; ? 1 : -1; return c \u0026gt;= 0 \u0026amp;\u0026amp; (x \u0026lt; m - 1 \u0026amp;\u0026amp; dfs(x + 1, y, c) || y \u0026lt; n - 1 \u0026amp;\u0026amp; dfs(x, y + 1, c)); // 往下或者往右 }; return dfs(0, 0, 0); } }; ","permalink":"https://www.liuchang0812.com/posts/tech/leetcode/2267/","summary":"LeetCode 2267 记忆化搜索解法","title":"2267. 检查是否有合法括号字符串路径"},{"content":"爬楼梯的加强版本，分别提前生成三个字母和四个字母的 fib 数组，然后分组统计后相乘。代码如下：\nclass Solution { public: int countTexts(string pressedKeys) { int f1[100005]; int f2[100005]; memset(f1, 0, sizeof f1); memset(f2, 0, sizeof f2); f1[0] = 1; f1[1] = 2; f1[2] = 4; f2[0] = 1; f2[1] = 2; f2[2] = 4; f2[3] = 8; for (int i=3; i\u0026lt;100005; ++i) f1[i] = (0LL + f1[i-1] + f1[i-2] + f1[i-3])%int(1e9+7); for (int i=4; i\u0026lt;100005; ++i) f2[i] = (0LL + f2[i-1] + f2[i-2] + f2[i-3] + f2[i-4])%int(1e9+7); int ans = 1; int cur_ch = pressedKeys[0]; int cur_cnt = 1; for (int i=1; i\u0026lt;pressedKeys.size(); ++i) { if (pressedKeys[i] != cur_ch) { if (cur_ch == \u0026#39;7\u0026#39; || cur_ch == \u0026#39;9\u0026#39;) ans = 1LL *ans * f2[cur_cnt - 1] % int(1e9+7); else ans = 1LL *ans * f1[cur_cnt - 1] % int(1e9+7); cur_ch = pressedKeys[i]; cur_cnt = 1; } else { ++ cur_cnt; } } if (cur_ch == \u0026#39;7\u0026#39; || cur_ch == \u0026#39;9\u0026#39;) ans = 1LL * ans * f2[cur_cnt - 1] % int(1e9+7); else ans = 1LL * ans * f1[cur_cnt - 1] % int(1e9+7); return ans; } }; ","permalink":"https://www.liuchang0812.com/posts/tech/leetcode/leetcode2266/","summary":"LeetCode 2266 动态规划解法","title":"2266. 统计打字方案数"},{"content":"尘劫: 知青畅想曲 一本名字和封面看起来都非常像地摊文学的书，实际上却是“中共党史出版社”出版的关于知青的报告文学，内容包含了大量真实的知青故事，读来让人不禁唏嘘。\n一个人的命运在历史的长河里太过于脆弱。\n里面最触动的一段是：知青为了保留回城的资格，会同居而不结婚，生的孩子没有办法上户口。在允许回城后，只能将孩子托付给当地人。\n","permalink":"https://www.liuchang0812.com/posts/read/2022-04-reading/","summary":"知青报告文学《尘劫》","title":"2022 04 读书分享:尘劫"},{"content":"Golang error 是一个包含了 Error() string 函数的接口，任何实现了 Error() string 的结构体都可以认为是 error 类型。\n// The error built-in interface type is the conventional interface for // representing an error condition, with the nil value representing no error. type error interface { Error() string } 对于简单场景，返回一个带字符串描述的 error 可以通过 return errors.New(\u0026quot;this is a err\u0026quot;) 来实现。其内部实现的机制为：定义了一个 errorString 的结构体，调用 Error() 的时候返回初始化时传入的字符串。\n// New returns an error that formats as the given text. // Each call to New returns a distinct error value even if the text is identical. func New(text string) error { return \u0026amp;errorString{text} } // errorString is a trivial implementation of error. type errorString struct { s string } func (e *errorString) Error() string { return e.s } 对于稍微复杂的场景，如果希望返回的错误信息中包含格式化字符串，可以通过 fmt.Errorf 来实现。其内部的实现为：通过一个 Printer 生成字符串，对于不包含异常的情况，调用上述的 errors.New。否则，返回一个 wrapError 结构体，保存包含的子 error ，并可以通过 Unwrap 取出。\nfunc Errorf(format string, a ...any) error { p := newPrinter() p.wrapErrs = true p.doPrintf(format, a) s := string(p.buf) var err error if p.wrappedErr == nil { err = errors.New(s) } else { err = \u0026amp;wrapError{s, p.wrappedErr} } p.free() return err } type wrapError struct { msg string err error } func (e *wrapError) Error() string { return e.msg } func (e *wrapError) Unwrap() error { return e.err } https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully ","permalink":"https://www.liuchang0812.com/posts/tech/golang/error-impl/","summary":"深入理解 Go error 接口及 errors.New 和 fmt.Errorf 的实现原理","title":"golang | error 的内部实现"},{"content":"[]byte 和 string 有什么区别？类型转换需要拷贝数据吗？如何选择正确的类型？\n[]byte和string的类型字义非常类似，[]byte 比 string 多一个 cap 成员。string 在大多数的语言中都表示不可变字符串，[]byte 则是可以修改的数组分片。所以在做 []byte 和 string 转换的时候，如果只是简单的将指针复制，就相当于同一块内存同时有了可变和不可变引用，修改了 []byte 会影响到 string 的不可变性（rust 选手应该比较熟悉）。所以做类型转换时，会额外的有内存申请与数据拷贝动作。\n至于在编码的时候该选择哪个类型，可以参考 andybalholm 的回答：尽量使用 string ，除非要频繁修改字符串或者要与使用的接口保持一致。\nMy advice would be to use string by default when you're working with text. But use []byte instead if one of the following conditions applies: - The mutability of a []byte will significantly reduce the number of allocations needed. - You are dealing with an API that uses []byte, and avoiding a conversion to string will simplify your code. type slice struct { data uintptr len int cap int } type string struct { data uintptr len int } // ByteSliceFromString returns a NUL-terminated slice of bytes // containing the text of s. If s contains a NUL byte at any // location, it returns (nil, syscall.EINVAL). func ByteSliceFromString(s string) ([]byte, error) { if strings.IndexByte(s, 0) != -1 { return nil, syscall.EINVAL } a := make([]byte, len(s)+1) copy(a, s) return a, nil } refs https://syslog.ravelin.com/byte-vs-string-in-go-d645b67ca7ff\nhttps://cs.opensource.google/go/go/+/master:src/cmd/vendor/golang.org/x/sys/windows/syscall.go;l=40?q=slicetostring\u0026amp;ss=go%2Fgo\nhttps://stackoverflow.com/questions/10826651/when-to-use-byte-or-string-in-go\n","permalink":"https://www.liuchang0812.com/posts/tech/golang/byte-slice-vs-string/","summary":"理解 Go 中 []byte 和 string 的区别及类型转换开销","title":"golang | []byte 和 string 的区别与适用场景"}]