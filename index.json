[{"content":"Paxos 协议与工程实现 写在前面，我没有完整实现过 Paxos 协议，不敢保证下面描述的内容完全正确。本文主要是学习的笔记，如果有错误，十分欢迎指出，大家一起讨论学习。\n本文所有内容都是参考 PaxosStore 论文 《PaxosStore: High-availability Storage Made Practical in WeChat》\n概念定义 为了后续方便描述，我们先定义会用到的概念\nProposal 提议，包含提议号和提议值； Prepare 第一阶段 Proposer 发出的请求，包含一个提议号； Promise 第一阶段 Proposer 回应的消息，包含一个提议号和一个（如果有）已经 Accepted 的最大提仪； Accept 第二阶段 Proposer 发出的请求，包含一个提议号和一个提议值； Accepted 第二阶段 Proposer 回应的消息，包含一个提议号。也表示一个提议被一个该 Proposer 接受； Chosen 代表一个提议被大多数的 Proposer 接受，不会再发生改变； Proposer 提议成员； Acceptor 发送 Accepted 消息的成员； Learner 学习者，不参与 Paxos 投票过程。 与可以用代码语言描述，参考 链接\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // Prepare 请求，包含一个提议号 struct Prepare { int n; }; // 在收到大多数的 Promised 请求后，发出的 Accept 请求，包含一个提仪号以及一个值。 // 这个值是 Promised 中最大提议号的值，如果所有 promised 都没有返回值，则可以自己提出任意值。 // 对应到工程实现上，则代表这个位置已经被占了，可以再起一轮新 paxos struct Accept { int n; void *value; }; // n 承诺不 accept 小于 n 的 accept 请求，返回当时最大提议号对应的值。 struct Promised { int n; Accept *proposal = nullptr; }; // 如果满足承诺，返回最大的提议号 struct Accepted { int n; }; // paxos 成员会在内存中纪录的值，包括最大的提议号，以及对应的值。 class Acceptor { int last_n = 0; Accept *proposal = nullptr; }; Basic Paxos 协议 Basic Paxos 是理论上的最基础的一致性算法，作用是：多个（奇数）成员确定唯一一个值。\n算法分为两轮，第一轮 Prepare 请求会得到承诺后续不通过小于本次 Prepare.n 的提议，同时返回自己已经 accepted 的最大提议。第二轮 Accept 请求会带上上一轮收到的最大提议值（如果没有，则可以自己提出），每个 Acceptor 在不违背承诺的情况下更新本地状态。\n一个提仪一旦被大多数结果 accepted，就会被认为是 chosen。对于一个值来说，accepted 还是可以变的，chosen 的永远不会变。一组经典的 paxos 实例只能确定（chosen）一个值。\n算法的详细描述可以参考论文：\nPhase 1.\nA proposer selects a proposal number n and sends a prepare request with number n to a majority of acceptors.\nIf an acceptor receives a prepare request with number n greater than that of any prepare request to which it has already responded, then it responds to the request with a promise not to accept any more proposals numbered less than n and with the highest-numbered proposal (if any) that it has accepted.\nPhase 2.\nIf the proposer receives a response to its prepare requests (numbered n) from a majority of acceptors, then it sends an accept request to each of those acceptors for a proposal numbered n with a value v, where v is the value of the highest-numbered proposal among the responses, or is any value if the responses reported no proposals.\nIf an acceptor receives an accept request for a proposal numbered n, it accepts the proposal unless it has already responded to a prepare request having a number greater than n.\n注意细节：\nAccept 请求中的 value 是一阶段返回所有 promised 中 n 最大的那个值。是 promised→proposal.n 的 n，而不是 promised.n acceptor 上 accept 值还是会被修改的。 在提议被大多数通过的一瞬间，这个值就确定下来了，再也不会被修改。 对于证明的思路是这么一种思路：证明一个值 chosen 不会被修改，可以通过加强的方式。如果一个大于当前提仪号并且值不同的提仪，不会被发出。chosen 的值自然就不会被修改。\nMulti Paxos 实现方法 可以看到，Basic Paxos 算法只能确定一个值，同时要走两轮流程。为了在真实系统上实际使用起来，还需要做一些修改优化。\n我们可以在 Basic Paxos 上增加一个 Entry ID 的维度，每个 Entry 保存一个值。同时，可以在第 i 个 Entry 中携带上第 i+1 个 Entry 的 Prepare 信息：当 $E_i$ 被 chosen 时，同时认为 $E_i+1$ 已经完成了 prepare 流程。\n工程实现上的问题 论文只描述了 Paxos 算法的流程和证明，在实际实现上，还有很多细节要处理，例如怎么 CatchUp、怎么 GetALL以及一些细节的问题。\n写读读问题 写读读的问题场景：假设三机日志都commit到了Entry 100，然后机器 A执行 Entry 101 的二轮过程然后挂掉。这个时候会读到 100 的值。然后机器 A 恢复同步状态到 BC，后续就读到了 Entry 101。\n重复执行问题 重复执行的问题场景：机器 A 收到一个写请求，在执行完 Paxos 后被 chosen，然后发送响应给客户端。这个响应可能因为网络原因未发到或者超时。然后客户端超时后重发请求到机器 B。机器 B 重新跑一次 Paxos 过程，然后回复客户端。这儿更新过程就会执行两次，如果是有状态的更新就会有问题。\n所以要让请求幂等，方法就是在请求上带上 request ID， svr 端检查 request ID 。\nThe request ID is generated by the client and sent together with the write request, and checked by the PaxosStore node to detect potential duplication of actual request handling.\nPlogKV 实现问题 文章同时提到了一个 PaxosLog for KV Data，可以优化掉 DB 部分的成本。那么正常的plog存储的key应该是entityid和entryid？怎么用key来查询？\n答案是只维护两个entry，一个最新chosen，一个pending。每个 key 都是一个 paxos 实例。\n参考 https://sf-zhou.github.io/paxos/paxos_store_03_consensus.html http://www.vldb.org/pvldb/vol10/p1730-lin.pdf ","permalink":"https://liuchang0812.github.io/posts/tech/os/paxos-note/","summary":"Paxos 协议与工程实现 写在前面，我没有完整实现过 Paxos 协议，不敢保证下面描述的内容完全正确。本文主要是学习的笔记，如果有错误，十分欢迎指出，大家一起讨","title":"Paxos Algorithm Note"},{"content":"cgroup 全称是 control group，是 linux 下的一个内核模块，用来控制进程的系统资源使用。例如可以限制进程 cpu 使用量、内存使用量等。比如知名开源软件 docker 就是基于 cgroup 来限制容器资源使用，使用 namespace 隔离进程空间。\ncgroup 分为 v1 和 v2 两个版本。常用的子系统有：\ncpu/cpuset/cpuacct：限制和统计 cpu 的用量 memory：限制内存的用量 blkio：限制块设备的用量，但是只能限制 direct io 使用方式 cgroup 基于 linux vfs 技术，将 cgroup 映射到一个目录。系统管理员通过在目录下创建文件的方式来使用 cgroup。默认情况下，cgroup 映射的目录为 /sys/fs/cgroup ，该目录下每个目录对应一个子系统。系统管理员可以在子系统目录中新建树状目录来设置 cgroup 限制，例如 /sys/fs/cgroup/cpu/g1 代表一类进程限制。\n1 2 ➜ ~ ls /sys/fs/cgroup blkio cpu cpuacct cpu,cpuacct cpuset devices freezer hugetlb memory net_cls oom perf_event pids systemd 除了使用 /sys/fs/cgroup ，还可以通过 cgcreate 、 cgexec 等命令来使用 cgroup。例如\n1 2 # 使用 /sys/fs/cgroup/cpu/test_cpu 来限制 ./test 进程运行 cgexec -g cpu:test_cpu ./test ","permalink":"https://liuchang0812.github.io/posts/tech/os/cgroup/","summary":"cgroup 全称是 control group，是 linux 下的一个内核模块，用来控制进程的系统资源使用。例如可以限制进程 cpu 使用量、内存使用量等。比如知名开源软件 docker 就是基于 cgroup","title":"cgroup usage"},{"content":" 我们以 C++11 的 API 接口定义来描述\n大家在编写多线程类的程序时，会用到信号量 condition_variable，有没有疑惑过为什么 cv 这类接口，在调用 wait/notify 时候还需要用一个 mutex。\n为什么 cv.wait() 需要用 mutex 保护？ 常见的 cv 代码实现类似下方，包含三个部分：检查条件是否满足；如果不满足等待到满足；等待到满足后执行逻辑。\n1 2 3 4 5 std::unique_lock\u0026lt;std::mutex\u0026gt; lock(cv_m); while (!cond_ok()) { // 1. 检查条件是否满足 wait(lock); // 2. 等待信号 } // do somethings with cond // 3. 执行逻辑 如果没有一个锁保护这三个部分，会出现两种情况：\n在第一部分检查条件不满足，准备进行第二部分 wait信号时，另一个线程达到了信号条件并 signal ，然后执行到 wait 。这个时候 wiat 就永远挂在这儿了。 在第二部分执行完成后，认为已经达到条件，准备执行第三部分的业务逻辑。另一个线程修改了条件。第三部分执行的假设是条件已经满足，违反了假设，业务逻辑可能会有问题。 所以一般会通过一个 mutex 将上述三个部分看起一个原子操作，将检查条件是否完成与等待信号量同时执行。其它线程如果 signal 信号，一定是在检查条件之前或者wait之后。\n附录 lock-and-condition-variable cppreference ","permalink":"https://liuchang0812.github.io/posts/tech/os/why-conv-need-a-mutex/","summary":"我们以 C++11 的 API 接口定义来描述 大家在编写多线程类的程序时，会用到信号量 condition_variable，有没有疑惑过为什么 cv 这类接口，在调用","title":"Why Does Conv Need a Mutex"},{"content":"书名：1984 政治小说，推荐指数 4 颗星\n小说虚构了一个极权社会，介绍了为真理部工作的外党成员温斯顿的故事。在极权社会下，到处都有电屏的监视。人们每天还要进行仇恨会的活动。对于不认同老大哥统治的思想有“问题”的人，会被思想警察完全从社会上抹去。\n主人公为真理部工作，工作内容是篡改历史，抹去被消失人的纪录。小说中主要分为两部分：一部分是认识女主，和女主发生的故事。另一部分则是被思想警察钓鱼执法，被惨烈的思想改造。\n书名：大逃港 政治向的报告文学，推荐指数 4 颗星\n这本书主要介绍了在建国后深圳人民群众逃港的故事。稍微的有点儿故事会写法。人民不管姓资还是姓社，只关心能不能吃饱肚子过上好日子，于是用脚投票，冒着生命危险去逃港。在改革开放后，则大量减少了逃港行为。\n书名：风格的要素 关于英语写作的小册子，推荐指数 2 颗星\n","permalink":"https://liuchang0812.github.io/posts/read/2205/","summary":"书名：1984 政治小说，推荐指数 4 颗星 小说虚构了一个极权社会，介绍了为真理部工作的外党成员温斯顿的故事。在极权社会下，到处都有电屏的监视。人","title":"2205 读书分享"},{"content":"记忆化搜索，刚好卡过去\n执行用时：1964 ms, 在所有 C++ 提交中击败了 5.08% 的用户\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 int mem[100][100][100][100]; class Solution { public: // 0 unknow // 1 true // 2 false bool dfs(const vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; grid, int x1, int y1, int x2, int y2) { if (x1 \u0026gt;= grid.size() || x2 \u0026gt;= grid.size() || y1\u0026gt;=grid[0].size() || y2 \u0026lt; 0 || x2 \u0026lt; 0 || x1 \u0026gt; x2 || y1 \u0026gt; y2) return false; if ((x2 - x1 + y2 - y1)%2==0) return false; if (mem[x1][y1][x2][y2] != 0) { return mem[x1][y1][x2][y2] == 1; } if ( x2 - x1 + y2 - y1 == 1 \u0026amp;\u0026amp; grid[x1][y1] == \u0026#39;(\u0026#39; \u0026amp;\u0026amp; grid[x2][y2] == \u0026#39;)\u0026#39;) { mem[x1][y1][x2][y2] = 1; return true; } if (grid[x1][y1] == \u0026#39;(\u0026#39; \u0026amp;\u0026amp; grid[x2][y2] == \u0026#39;)\u0026#39;){ bool tmp = dfs(grid, x1+1, y1, x2-1, y2) || dfs(grid, x1+1, y1, x2, y2-1) || dfs(grid, x1, y1+1, x2-1, y2) || dfs(grid, x1, y1+1, x2, y2-1); if (tmp) { mem[x1][y1][x2][y2] = 1; return true; } for (int i=x1; i\u0026lt;=x2; ++i) for (int j=y1; j\u0026lt;=y2; ++j) { if (i == x1 \u0026amp;\u0026amp; j==y1) continue; if (i == x2 \u0026amp;\u0026amp; j==y2) continue; if ((dfs(grid, x1, y1, i, j) \u0026amp;\u0026amp; dfs(grid, i, j+1, x2, y2))) { mem[x1][y1][x2][y2] = 1; return true; } if (dfs(grid, x1, y1, i, j) \u0026amp;\u0026amp; dfs(grid, i+1, j, x2, y2)) { mem[x1][y1][x2][y2] = 1; return true; } } mem[x1][y1][x2][y2] = 2; return false; } else { mem[x1][y1][x2][y2] = 2; return false; } } bool hasValidPath(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; grid) { int row = grid.size(); int col = grid[0].size(); if ((row + col)%2==0) return false; if ( grid[0][0] == \u0026#39;)\u0026#39; || grid[row - 1][col - 1] == \u0026#39;(\u0026#39;) return false; memset(mem, 0, sizeof mem); return dfs(grid, 0, 0, row-1, col -1); } }; 题解里面有一个写法很好，可以学习一下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: bool hasValidPath(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; \u0026amp;grid) { int m = grid.size(), n = grid[0].size(); if ((m + n) % 2 == 0 || grid[0][0] == \u0026#39;)\u0026#39; || grid[m - 1][n - 1] == \u0026#39;(\u0026#39;) return false; // 剪枝 bool vis[m][n][(m + n + 1) / 2]; memset(vis, 0, sizeof(vis)); function\u0026lt;bool(int, int, int)\u0026gt; dfs = [\u0026amp;](int x, int y, int c) -\u0026gt; bool { if (c \u0026gt; m - x + n - y - 1) return false; // 剪枝：即使后面都是 \u0026#39;)\u0026#39; 也不能将 c 减为 0 if (x == m - 1 \u0026amp;\u0026amp; y == n - 1) return c == 1; // 终点一定是 \u0026#39;)\u0026#39; if (vis[x][y][c]) return false; // 重复访问 vis[x][y][c] = true; c += grid[x][y] == \u0026#39;(\u0026#39; ? 1 : -1; return c \u0026gt;= 0 \u0026amp;\u0026amp; (x \u0026lt; m - 1 \u0026amp;\u0026amp; dfs(x + 1, y, c) || y \u0026lt; n - 1 \u0026amp;\u0026amp; dfs(x, y + 1, c)); // 往下或者往右 }; return dfs(0, 0, 0); } }; ","permalink":"https://liuchang0812.github.io/posts/tech/leetcode/2267/","summary":"记忆化搜索，刚好卡过去 执行用时：1964 ms, 在所有 C++ 提交中击败了 5.08% 的用户 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35","title":"2267. 检查是否有合法括号字符串路径"},{"content":"爬楼梯的加强版本，分别提前生成三个字母和四个字母的 fib 数组，然后分组统计后相乘。代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { public: int countTexts(string pressedKeys) { int f1[100005]; int f2[100005]; memset(f1, 0, sizeof f1); memset(f2, 0, sizeof f2); f1[0] = 1; f1[1] = 2; f1[2] = 4; f2[0] = 1; f2[1] = 2; f2[2] = 4; f2[3] = 8; for (int i=3; i\u0026lt;100005; ++i) f1[i] = (0LL + f1[i-1] + f1[i-2] + f1[i-3])%int(1e9+7); for (int i=4; i\u0026lt;100005; ++i) f2[i] = (0LL + f2[i-1] + f2[i-2] + f2[i-3] + f2[i-4])%int(1e9+7); int ans = 1; int cur_ch = pressedKeys[0]; int cur_cnt = 1; for (int i=1; i\u0026lt;pressedKeys.size(); ++i) { if (pressedKeys[i] != cur_ch) { if (cur_ch == \u0026#39;7\u0026#39; || cur_ch == \u0026#39;9\u0026#39;) ans = 1LL *ans * f2[cur_cnt - 1] % int(1e9+7); else ans = 1LL *ans * f1[cur_cnt - 1] % int(1e9+7); cur_ch = pressedKeys[i]; cur_cnt = 1; } else { ++ cur_cnt; } } if (cur_ch == \u0026#39;7\u0026#39; || cur_ch == \u0026#39;9\u0026#39;) ans = 1LL * ans * f2[cur_cnt - 1] % int(1e9+7); else ans = 1LL * ans * f1[cur_cnt - 1] % int(1e9+7); return ans; } }; ","permalink":"https://liuchang0812.github.io/posts/tech/leetcode/leetcode2266/","summary":"爬楼梯的加强版本，分别提前生成三个字母和四个字母的 fib 数组，然后分组统计后相乘。代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26","title":"2266. 统计打字方案数"},{"content":"一本名字和封面看起来都非常像地摊文学的书，实际上却是“中共党史出版社”出版的关于知青的报告文学，内容包含了大量真实的知青故事，读来让人不禁唏嘘。\n一个人的命运在历史的长河里太过于脆弱。\n里面最触动的一段是：知青为了保留回城的资格，会同居而不结婚，生的孩子没有办法上户口。在允许回城后，只能将孩子托付给当地人。\n","permalink":"https://liuchang0812.github.io/posts/read/chenjie/","summary":"一本名字和封面看起来都非常像地摊文学的书，实际上却是“中共党史出版社”出版的关于知青的报告文学，内容包含了大量真实的知青故事，读来让人不禁唏","title":"读书笔记 | 尘劫: 知青畅想曲"},{"content":"会写点儿 Cpp/Python 的码农，了解一点儿分布式存储系统\n","permalink":"https://liuchang0812.github.io/about/","summary":"会写点儿 Cpp/Python 的码农，了解一点儿分布式存储系统","title":"ABOUT"},{"content":"Golang error 是一个包含了 Error() string 函数的接口，任何实现了 Error() string 的结构体都可以认为是 error 类型。\n1 2 3 4 5 // The error built-in interface type is the conventional interface for // representing an error condition, with the nil value representing no error. type error interface { Error() string } 对于简单场景，返回一个带字符串描述的 error 可以通过 return errors.New(\u0026quot;this is a err\u0026quot;) 来实现。其内部实现的机制为：定义了一个 errorString 的结构体，调用 Error() 的时候返回初始化时传入的字符串。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // New returns an error that formats as the given text. // Each call to New returns a distinct error value even if the text is identical. func New(text string) error { return \u0026amp;errorString{text} } // errorString is a trivial implementation of error. type errorString struct { s string } func (e *errorString) Error() string { return e.s } 对于稍微复杂的场景，如果希望返回的错误信息中包含格式化字符串，可以通过 fmt.Errorf 来实现。其内部的实现为：通过一个 Printer 生成字符串，对于不包含异常的情况，调用上述的 errors.New。否则，返回一个 wrapError 结构体，保存包含的子 error ，并可以通过 Unwrap 取出。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 func Errorf(format string, a ...any) error { p := newPrinter() p.wrapErrs = true p.doPrintf(format, a) s := string(p.buf) var err error if p.wrappedErr == nil { err = errors.New(s) } else { err = \u0026amp;wrapError{s, p.wrappedErr} } p.free() return err } type wrapError struct { msg string err error } func (e *wrapError) Error() string { return e.msg } func (e *wrapError) Unwrap() error { return e.err } https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully ","permalink":"https://liuchang0812.github.io/posts/tech/golang/error-impl/","summary":"Golang error 是一个包含了 Error() string 函数的接口，任何实现了 Error() string 的结构体都可以认为是 error 类型。 1 2 3 4 5 // The error built-in interface type is the conventional interface for // representing an error condition, with the nil value representing no error. type error interface { Error()","title":"golang | error 的内部实现"},{"content":"[]byte 和 string 有什么区别？类型转换需要拷贝数据吗？如何选择正确的类型？\n[]byte和string的类型字义非常类似，[]byte 比 string 多一个 cap 成员。string 在大多数的语言中都表示不可变字符串，[]byte 则是可以修改的数组分片。所以在做 []byte 和 string 转换的时候，如果只是简单的将指针复制，就相当于同一块内存同时有了可变和不可变引用，修改了 []byte 会影响到 string 的不可变性（rust 选手应该比较熟悉）。所以做类型转换时，会额外的有内存申请与数据拷贝动作。\n至于在编码的时候该选择哪个类型，可以参考 andybalholm 的回答：尽量使用 string ，除非要频繁修改字符串或者要与使用的接口保持一致。\nMy advice would be to use string by default when you're working with text. But use []byte instead if one of the following conditions applies: - The mutability of a []byte will significantly reduce the number of allocations needed. - You are dealing with an API that uses []byte, and avoiding a conversion to string will simplify your code. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 type slice struct { data uintptr len int cap int } type string struct { data uintptr len int } // ByteSliceFromString returns a NUL-terminated slice of bytes // containing the text of s. If s contains a NUL byte at any // location, it returns (nil, syscall.EINVAL). func ByteSliceFromString(s string) ([]byte, error) { if strings.IndexByte(s, 0) != -1 { return nil, syscall.EINVAL } a := make([]byte, len(s)+1) copy(a, s) return a, nil } refs https://syslog.ravelin.com/byte-vs-string-in-go-d645b67ca7ff\nhttps://cs.opensource.google/go/go/+/master:src/cmd/vendor/golang.org/x/sys/windows/syscall.go;l=40?q=slicetostring\u0026amp;ss=go%2Fgo\nhttps://stackoverflow.com/questions/10826651/when-to-use-byte-or-string-in-go\n","permalink":"https://liuchang0812.github.io/posts/tech/golang/byte-slice-vs-string/","summary":"[]byte 和 string 有什么区别？类型转换需要拷贝数据吗？如何选择正确的类型？ []byte和string的类型字义非常类似，[]byte 比 string 多一个 cap 成员。s","title":"golang | []byte 和 string 的区别与适用场景"}]