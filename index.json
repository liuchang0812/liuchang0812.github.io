[{"content":"记忆化搜索，刚好卡过去\n 执行用时：1964 ms, 在所有 C++ 提交中击败了 5.08% 的用户\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65    int mem[100][100][100][100];  class Solution { public:  // 0 unknow  // 1 true  // 2 false  bool dfs(const vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; grid, int x1, int y1, int x2, int y2) {  if (x1 \u0026gt;= grid.size() || x2 \u0026gt;= grid.size() || y1\u0026gt;=grid[0].size() || y2 \u0026lt; 0 || x2 \u0026lt; 0 || x1 \u0026gt; x2 || y1 \u0026gt; y2)  return false;  if ((x2 - x1 + y2 - y1)%2==0) return false;   if (mem[x1][y1][x2][y2] != 0) {  return mem[x1][y1][x2][y2] == 1;  }  if ( x2 - x1 + y2 - y1 == 1 \u0026amp;\u0026amp; grid[x1][y1] == \u0026#39;(\u0026#39; \u0026amp;\u0026amp; grid[x2][y2] == \u0026#39;)\u0026#39;) {  mem[x1][y1][x2][y2] = 1;  return true;  }   if (grid[x1][y1] == \u0026#39;(\u0026#39; \u0026amp;\u0026amp; grid[x2][y2] == \u0026#39;)\u0026#39;){  bool tmp = dfs(grid, x1+1, y1, x2-1, y2) ||  dfs(grid, x1+1, y1, x2, y2-1) ||  dfs(grid, x1, y1+1, x2-1, y2) ||  dfs(grid, x1, y1+1, x2, y2-1);  if (tmp) {  mem[x1][y1][x2][y2] = 1;  return true;  }   for (int i=x1; i\u0026lt;=x2; ++i)  for (int j=y1; j\u0026lt;=y2; ++j) {  if (i == x1 \u0026amp;\u0026amp; j==y1) continue;  if (i == x2 \u0026amp;\u0026amp; j==y2) continue;  if ((dfs(grid, x1, y1, i, j) \u0026amp;\u0026amp; dfs(grid, i, j+1, x2, y2))) {  mem[x1][y1][x2][y2] = 1;  return true;  }  if (dfs(grid, x1, y1, i, j) \u0026amp;\u0026amp; dfs(grid, i+1, j, x2, y2)) {  mem[x1][y1][x2][y2] = 1;  return true;  }  }  mem[x1][y1][x2][y2] = 2;  return false;  }  else {  mem[x1][y1][x2][y2] = 2;  return false;  }  }    bool hasValidPath(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; grid) {  int row = grid.size();  int col = grid[0].size();  if ((row + col)%2==0) return false;   if ( grid[0][0] == \u0026#39;)\u0026#39; || grid[row - 1][col - 1] == \u0026#39;(\u0026#39;) return false;   memset(mem, 0, sizeof mem);  return dfs(grid, 0, 0, row-1, col -1);  } };   题解里面有一个写法很好，可以学习一下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18   class Solution { public:  bool hasValidPath(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; \u0026amp;grid) {  int m = grid.size(), n = grid[0].size();  if ((m + n) % 2 == 0 || grid[0][0] == \u0026#39;)\u0026#39; || grid[m - 1][n - 1] == \u0026#39;(\u0026#39;) return false; // 剪枝  bool vis[m][n][(m + n + 1) / 2]; memset(vis, 0, sizeof(vis));  function\u0026lt;bool(int, int, int)\u0026gt; dfs = [\u0026amp;](int x, int y, int c) -\u0026gt; bool {  if (c \u0026gt; m - x + n - y - 1) return false; // 剪枝：即使后面都是 \u0026#39;)\u0026#39; 也不能将 c 减为 0  if (x == m - 1 \u0026amp;\u0026amp; y == n - 1) return c == 1; // 终点一定是 \u0026#39;)\u0026#39;  if (vis[x][y][c]) return false; // 重复访问  vis[x][y][c] = true;  c += grid[x][y] == \u0026#39;(\u0026#39; ? 1 : -1;  return c \u0026gt;= 0 \u0026amp;\u0026amp; (x \u0026lt; m - 1 \u0026amp;\u0026amp; dfs(x + 1, y, c) || y \u0026lt; n - 1 \u0026amp;\u0026amp; dfs(x, y + 1, c)); // 往下或者往右  };  return dfs(0, 0, 0);  } };   ","permalink":"https://liuchang0812.github.io/posts/tech/leetcode/2267/","summary":"记忆化搜索，刚好卡过去 执行用时：1964 ms, 在所有 C++ 提交中击败了 5.08% 的用户 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35","title":"2267. 检查是否有合法括号字符串路径"},{"content":"爬楼梯的加强版本，分别提前生成三个字母和四个字母的 fib 数组，然后分组统计后相乘。代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40   class Solution { public:   int countTexts(string pressedKeys) {  int f1[100005];  int f2[100005];  memset(f1, 0, sizeof f1);  memset(f2, 0, sizeof f2);   f1[0] = 1; f1[1] = 2; f1[2] = 4;  f2[0] = 1; f2[1] = 2; f2[2] = 4; f2[3] = 8;   for (int i=3; i\u0026lt;100005; ++i) f1[i] = (0LL + f1[i-1] + f1[i-2] + f1[i-3])%int(1e9+7);  for (int i=4; i\u0026lt;100005; ++i) f2[i] = (0LL + f2[i-1] + f2[i-2] + f2[i-3] + f2[i-4])%int(1e9+7);  int ans = 1;  int cur_ch = pressedKeys[0];  int cur_cnt = 1;  for (int i=1; i\u0026lt;pressedKeys.size(); ++i) {  if (pressedKeys[i] != cur_ch) {  if (cur_ch == \u0026#39;7\u0026#39; || cur_ch == \u0026#39;9\u0026#39;)  ans = 1LL *ans * f2[cur_cnt - 1] % int(1e9+7);  else  ans = 1LL *ans * f1[cur_cnt - 1] % int(1e9+7);   cur_ch = pressedKeys[i];  cur_cnt = 1;  } else {  ++ cur_cnt;  }  }   if (cur_ch == \u0026#39;7\u0026#39; || cur_ch == \u0026#39;9\u0026#39;)  ans = 1LL * ans * f2[cur_cnt - 1] % int(1e9+7);  else  ans = 1LL * ans * f1[cur_cnt - 1] % int(1e9+7);   return ans;  } };   ","permalink":"https://liuchang0812.github.io/posts/tech/leetcode/leetcode2266/","summary":"爬楼梯的加强版本，分别提前生成三个字母和四个字母的 fib 数组，然后分组统计后相乘。代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26","title":"2266. 统计打字方案数"},{"content":"一本名字和封面看起来都非常像地摊文学的书，实际上却是“中共党史出版社”出版的关于知青的报告文学，内容包含了大量真实的知青故事，读来让人不禁唏嘘。\n 一个人的命运在历史的长河里太过于脆弱。\n 里面最触动的一段是：知青为了保留回城的资格，会同居而不结婚，生的孩子没有办法上户口。在允许回城后，只能将孩子托付给当地人。\n","permalink":"https://liuchang0812.github.io/posts/read/chenjie/","summary":"一本名字和封面看起来都非常像地摊文学的书，实际上却是“中共党史出版社”出版的关于知青的报告文学，内容包含了大量真实的知青故事，读来让人不禁唏","title":"读书笔记 | 尘劫: 知青畅想曲"},{"content":"会写点儿 Cpp/Python 的码农，了解一点儿分布式存储系统\n","permalink":"https://liuchang0812.github.io/about/","summary":"会写点儿 Cpp/Python 的码农，了解一点儿分布式存储系统","title":"ABOUT"},{"content":"Golang error 是一个包含了 Error() string 函数的接口，任何实现了 Error() string 的结构体都可以认为是 error 类型。\n1 2 3 4 5  // The error built-in interface type is the conventional interface for // representing an error condition, with the nil value representing no error. type error interface { \tError() string }   对于简单场景，返回一个带字符串描述的 error 可以通过 return errors.New(\u0026quot;this is a err\u0026quot;) 来实现。其内部实现的机制为：定义了一个 errorString 的结构体，调用 Error() 的时候返回初始化时传入的字符串。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  // New returns an error that formats as the given text. // Each call to New returns a distinct error value even if the text is identical. func New(text string) error { \treturn \u0026amp;errorString{text} }  // errorString is a trivial implementation of error. type errorString struct { \ts string }  func (e *errorString) Error() string { \treturn e.s }   对于稍微复杂的场景，如果希望返回的错误信息中包含格式化字符串，可以通过 fmt.Errorf 来实现。其内部的实现为：通过一个 Printer 生成字符串，对于不包含异常的情况，调用上述的 errors.New。否则，返回一个 wrapError 结构体，保存包含的子 error ，并可以通过 Unwrap 取出。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  func Errorf(format string, a ...any) error { \tp := newPrinter() \tp.wrapErrs = true \tp.doPrintf(format, a) \ts := string(p.buf) \tvar err error \tif p.wrappedErr == nil { \terr = errors.New(s) \t} else { \terr = \u0026amp;wrapError{s, p.wrappedErr} \t} \tp.free() \treturn err }  type wrapError struct { \tmsg string \terr error }  func (e *wrapError) Error() string { \treturn e.msg }  func (e *wrapError) Unwrap() error { \treturn e.err }    https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully  ","permalink":"https://liuchang0812.github.io/posts/tech/golang/error-impl/","summary":"Golang error 是一个包含了 Error() string 函数的接口，任何实现了 Error() string 的结构体都可以认为是 error 类型。 1 2 3 4 5 // The error built-in interface type is the conventional interface for // representing an error condition, with the nil value representing no error. type error interface { Error()","title":"golang | error 的内部实现"},{"content":"[]byte 和 string 有什么区别？类型转换需要拷贝数据吗？如何选择正确的类型？\n[]byte和string的类型字义非常类似，[]byte 比 string 多一个 cap 成员。string 在大多数的语言中都表示不可变字符串，[]byte 则是可以修改的数组分片。所以在做 []byte 和 string 转换的时候，如果只是简单的将指针复制，就相当于同一块内存同时有了可变和不可变引用，修改了 []byte 会影响到 string 的不可变性（rust 选手应该比较熟悉）。所以做类型转换时，会额外的有内存申请与数据拷贝动作。\n至于在编码的时候该选择哪个类型，可以参考 andybalholm 的回答：尽量使用 string ，除非要频繁修改字符串或者要与使用的接口保持一致。\nMy advice would be to use string by default when you're working with text. But use []byte instead if one of the following conditions applies: - The mutability of a []byte will significantly reduce the number of allocations needed. - You are dealing with an API that uses []byte, and avoiding a conversion to string will simplify your code.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  type slice struct {  data uintptr  len int  cap int }  type string struct {  data uintptr  len int }  // ByteSliceFromString returns a NUL-terminated slice of bytes // containing the text of s. If s contains a NUL byte at any // location, it returns (nil, syscall.EINVAL). func ByteSliceFromString(s string) ([]byte, error) { \tif strings.IndexByte(s, 0) != -1 { \treturn nil, syscall.EINVAL \t} \ta := make([]byte, len(s)+1) \tcopy(a, s) \treturn a, nil }   refs https://syslog.ravelin.com/byte-vs-string-in-go-d645b67ca7ff\nhttps://cs.opensource.google/go/go/+/master:src/cmd/vendor/golang.org/x/sys/windows/syscall.go;l=40?q=slicetostring\u0026amp;ss=go%2Fgo\nhttps://stackoverflow.com/questions/10826651/when-to-use-byte-or-string-in-go\n","permalink":"https://liuchang0812.github.io/posts/tech/golang/byte-slice-vs-string/","summary":"[]byte 和 string 有什么区别？类型转换需要拷贝数据吗？如何选择正确的类型？ []byte和string的类型字义非常类似，[]byte 比 string 多一个 cap 成员。s","title":"golang | []byte 和 string 的区别与适用场景"}]