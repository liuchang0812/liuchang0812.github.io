[{"content":"一本名字和封面看起来都非常像地摊文学的书，实际上却是“中共党史出版社”出版的关于知青的报告文学，内容包含了大量真实的知青故事，读来让人不禁唏嘘。\n 一个人的命运在历史的长河里太过于脆弱。\n 里面最触动的一段是：知青为了保留回城的资格，会同居而不结婚，生的孩子没有办法上户口。在允许回城后，只能将孩子托付给当地人。\n","permalink":"https://liuchang0812.github.io/posts/read/chenjie/","summary":"一本名字和封面看起来都非常像地摊文学的书，实际上却是“中共党史出版社”出版的关于知青的报告文学，内容包含了大量真实的知青故事，读来让人不禁唏","title":"读书笔记 | 尘劫: 知青畅想曲"},{"content":"会写点儿 Cpp/Python 的码农，了解一点儿分布式存储系统\n","permalink":"https://liuchang0812.github.io/about/","summary":"会写点儿 Cpp/Python 的码农，了解一点儿分布式存储系统","title":"ABOUT"},{"content":"Golang error 是一个包含了 Error() string 函数的接口，任何实现了 Error() string 的结构体都可以认为是 error 类型。\n1 2 3 4 5  // The error built-in interface type is the conventional interface for // representing an error condition, with the nil value representing no error. type error interface { \tError() string }   对于简单场景，返回一个带字符串描述的 error 可以通过 return errors.New(\u0026quot;this is a err\u0026quot;) 来实现。其内部实现的机制为：定义了一个 errorString 的结构体，调用 Error() 的时候返回初始化时传入的字符串。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  // New returns an error that formats as the given text. // Each call to New returns a distinct error value even if the text is identical. func New(text string) error { \treturn \u0026amp;errorString{text} }  // errorString is a trivial implementation of error. type errorString struct { \ts string }  func (e *errorString) Error() string { \treturn e.s }   对于稍微复杂的场景，如果希望返回的错误信息中包含格式化字符串，可以通过 fmt.Errorf 来实现。其内部的实现为：通过一个 Printer 生成字符串，对于不包含异常的情况，调用上述的 errors.New。否则，返回一个 wrapError 结构体，保存包含的子 error ，并可以通过 Unwrap 取出。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  func Errorf(format string, a ...any) error { \tp := newPrinter() \tp.wrapErrs = true \tp.doPrintf(format, a) \ts := string(p.buf) \tvar err error \tif p.wrappedErr == nil { \terr = errors.New(s) \t} else { \terr = \u0026amp;wrapError{s, p.wrappedErr} \t} \tp.free() \treturn err }  type wrapError struct { \tmsg string \terr error }  func (e *wrapError) Error() string { \treturn e.msg }  func (e *wrapError) Unwrap() error { \treturn e.err }    https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully  ","permalink":"https://liuchang0812.github.io/posts/tech/golang/error-impl/","summary":"Golang error 是一个包含了 Error() string 函数的接口，任何实现了 Error() string 的结构体都可以认为是 error 类型。 1 2 3 4 5 // The error built-in interface type is the conventional interface for // representing an error condition, with the nil value representing no error. type error interface { Error()","title":"Golang | error 的内部实现"},{"content":"[]byte 和 string 有什么区别？类型转换需要拷贝数据吗？如何选择正确的类型？\n[]byte和string的类型字义非常类似，[]byte 比 string 多一个 cap 成员。string 在大多数的语言中都表示不可变字符串，[]byte 则是可以修改的数组分片。所以在做 []byte 和 string 转换的时候，如果只是简单的将指针复制，就相当于同一块内存同时有了可变和不可变引用，修改了 []byte 会影响到 string 的不可变性（rust 选手应该比较熟悉）。所以做类型转换时，会额外的有内存申请与数据拷贝动作。\n至于在编码的时候该选择哪个类型，可以参考 andybalholm 的回答：尽量使用 string ，除非要频繁修改字符串或者要与使用的接口保持一致。\nMy advice would be to use string by default when you're working with text. But use []byte instead if one of the following conditions applies: - The mutability of a []byte will significantly reduce the number of allocations needed. - You are dealing with an API that uses []byte, and avoiding a conversion to string will simplify your code.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  type slice struct {  data uintptr  len int  cap int }  type string struct {  data uintptr  len int }  // ByteSliceFromString returns a NUL-terminated slice of bytes // containing the text of s. If s contains a NUL byte at any // location, it returns (nil, syscall.EINVAL). func ByteSliceFromString(s string) ([]byte, error) { \tif strings.IndexByte(s, 0) != -1 { \treturn nil, syscall.EINVAL \t} \ta := make([]byte, len(s)+1) \tcopy(a, s) \treturn a, nil }   refs https://syslog.ravelin.com/byte-vs-string-in-go-d645b67ca7ff\nhttps://cs.opensource.google/go/go/+/master:src/cmd/vendor/golang.org/x/sys/windows/syscall.go;l=40?q=slicetostring\u0026amp;ss=go%2Fgo\nhttps://stackoverflow.com/questions/10826651/when-to-use-byte-or-string-in-go\n","permalink":"https://liuchang0812.github.io/posts/tech/golang/byte-slice-vs-string/","summary":"[]byte 和 string 有什么区别？类型转换需要拷贝数据吗？如何选择正确的类型？ []byte和string的类型字义非常类似，[]byte 比 string 多一个 cap 成员。s","title":"golang | []byte 和 string 的区别与适用场景"}]