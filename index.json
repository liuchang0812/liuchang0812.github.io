[{"content":" 我们以 C++11 的 API 接口定义来描述\n大家在编写多线程类的程序时，会用到信号量 condition_variable，有没有疑惑过为什么 cv 这类接口，在调用 wait/notify 时候还需要用一个 mutex。\n为什么 cv.wait() 需要用 mutex 保护？ 常见的 cv 代码实现类似下方，包含三个部分：检查条件是否满足；如果不满足等待到满足；等待到满足后执行逻辑。\n1 2 3 4 5 std::unique_lock\u0026lt;std::mutex\u0026gt; lock(cv_m); while (!cond_ok()) { // 1. 检查条件是否满足 wait(lock); // 2. 等待信号 } // do somethings with cond // 3. 执行逻辑 如果没有一个锁保护这三个部分，会出现两种情况：\n在第一部分检查条件不满足，准备进行第二部分 wait信号时，另一个线程达到了信号条件并 signal ，然后执行到 wait 。这个时候 wiat 就永远挂在这儿了。 在第二部分执行完成后，认为已经达到条件，准备执行第三部分的业务逻辑。另一个线程修改了条件。第三部分执行的假设是条件已经满足，违反了假设，业务逻辑可能会有问题。 所以一般会通过一个 mutex 将上述三个部分看起一个原子操作，将检查条件是否完成与等待信号量同时执行。其它线程如果 signal 信号，一定是在检查条件之前或者wait之后。\n附录 lock-and-condition-variable cppreference ","permalink":"https://liuchang0812.github.io/posts/tech/os/why-conv-need-a-mutex/","summary":"我们以 C++11 的 API 接口定义来描述 大家在编写多线程类的程序时，会用到信号量 condition_variable，有没有疑惑过为什么 cv 这类接口，在调用","title":"Why Does Conv Need a Mutex"},{"content":"书名：1984 政治小说，推荐指数 4 颗星\n小说虚构了一个极权社会，介绍了为真理部工作的外党成员温斯顿的故事。在极权社会下，到处都有电屏的监视。人们每天还要进行仇恨会的活动。对于不认同老大哥统治的思想有“问题”的人，会被思想警察完全从社会上抹去。\n主人公为真理部工作，工作内容是篡改历史，抹去被消失人的纪录。小说中主要分为两部分：一部分是认识女主，和女主发生的故事。另一部分则是被思想警察钓鱼执法，被惨烈的思想改造。\n书名：大逃港 政治向的报告文学，推荐指数 4 颗星\n这本书主要介绍了在建国后深圳人民群众逃港的故事。稍微的有点儿故事会写法。人民不管姓资还是姓社，只关心能不能吃饱肚子过上好日子，于是用脚投票，冒着生命危险去逃港。在改革开放后，则大量减少了逃港行为。\n书名：风格的要素 关于英语写作的小册子，推荐指数 2 颗星\n","permalink":"https://liuchang0812.github.io/posts/read/2205/","summary":"书名：1984 政治小说，推荐指数 4 颗星 小说虚构了一个极权社会，介绍了为真理部工作的外党成员温斯顿的故事。在极权社会下，到处都有电屏的监视。人","title":"2205 读书分享"},{"content":"记忆化搜索，刚好卡过去\n执行用时：1964 ms, 在所有 C++ 提交中击败了 5.08% 的用户\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 int mem[100][100][100][100]; class Solution { public: // 0 unknow // 1 true // 2 false bool dfs(const vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; grid, int x1, int y1, int x2, int y2) { if (x1 \u0026gt;= grid.size() || x2 \u0026gt;= grid.size() || y1\u0026gt;=grid[0].size() || y2 \u0026lt; 0 || x2 \u0026lt; 0 || x1 \u0026gt; x2 || y1 \u0026gt; y2) return false; if ((x2 - x1 + y2 - y1)%2==0) return false; if (mem[x1][y1][x2][y2] != 0) { return mem[x1][y1][x2][y2] == 1; } if ( x2 - x1 + y2 - y1 == 1 \u0026amp;\u0026amp; grid[x1][y1] == \u0026#39;(\u0026#39; \u0026amp;\u0026amp; grid[x2][y2] == \u0026#39;)\u0026#39;) { mem[x1][y1][x2][y2] = 1; return true; } if (grid[x1][y1] == \u0026#39;(\u0026#39; \u0026amp;\u0026amp; grid[x2][y2] == \u0026#39;)\u0026#39;){ bool tmp = dfs(grid, x1+1, y1, x2-1, y2) || dfs(grid, x1+1, y1, x2, y2-1) || dfs(grid, x1, y1+1, x2-1, y2) || dfs(grid, x1, y1+1, x2, y2-1); if (tmp) { mem[x1][y1][x2][y2] = 1; return true; } for (int i=x1; i\u0026lt;=x2; ++i) for (int j=y1; j\u0026lt;=y2; ++j) { if (i == x1 \u0026amp;\u0026amp; j==y1) continue; if (i == x2 \u0026amp;\u0026amp; j==y2) continue; if ((dfs(grid, x1, y1, i, j) \u0026amp;\u0026amp; dfs(grid, i, j+1, x2, y2))) { mem[x1][y1][x2][y2] = 1; return true; } if (dfs(grid, x1, y1, i, j) \u0026amp;\u0026amp; dfs(grid, i+1, j, x2, y2)) { mem[x1][y1][x2][y2] = 1; return true; } } mem[x1][y1][x2][y2] = 2; return false; } else { mem[x1][y1][x2][y2] = 2; return false; } } bool hasValidPath(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; grid) { int row = grid.size(); int col = grid[0].size(); if ((row + col)%2==0) return false; if ( grid[0][0] == \u0026#39;)\u0026#39; || grid[row - 1][col - 1] == \u0026#39;(\u0026#39;) return false; memset(mem, 0, sizeof mem); return dfs(grid, 0, 0, row-1, col -1); } }; 题解里面有一个写法很好，可以学习一下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: bool hasValidPath(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; \u0026amp;grid) { int m = grid.size(), n = grid[0].size(); if ((m + n) % 2 == 0 || grid[0][0] == \u0026#39;)\u0026#39; || grid[m - 1][n - 1] == \u0026#39;(\u0026#39;) return false; // 剪枝 bool vis[m][n][(m + n + 1) / 2]; memset(vis, 0, sizeof(vis)); function\u0026lt;bool(int, int, int)\u0026gt; dfs = [\u0026amp;](int x, int y, int c) -\u0026gt; bool { if (c \u0026gt; m - x + n - y - 1) return false; // 剪枝：即使后面都是 \u0026#39;)\u0026#39; 也不能将 c 减为 0 if (x == m - 1 \u0026amp;\u0026amp; y == n - 1) return c == 1; // 终点一定是 \u0026#39;)\u0026#39; if (vis[x][y][c]) return false; // 重复访问 vis[x][y][c] = true; c += grid[x][y] == \u0026#39;(\u0026#39; ? 1 : -1; return c \u0026gt;= 0 \u0026amp;\u0026amp; (x \u0026lt; m - 1 \u0026amp;\u0026amp; dfs(x + 1, y, c) || y \u0026lt; n - 1 \u0026amp;\u0026amp; dfs(x, y + 1, c)); // 往下或者往右 }; return dfs(0, 0, 0); } }; ","permalink":"https://liuchang0812.github.io/posts/tech/leetcode/2267/","summary":"记忆化搜索，刚好卡过去 执行用时：1964 ms, 在所有 C++ 提交中击败了 5.08% 的用户 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35","title":"2267. 检查是否有合法括号字符串路径"},{"content":"爬楼梯的加强版本，分别提前生成三个字母和四个字母的 fib 数组，然后分组统计后相乘。代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { public: int countTexts(string pressedKeys) { int f1[100005]; int f2[100005]; memset(f1, 0, sizeof f1); memset(f2, 0, sizeof f2); f1[0] = 1; f1[1] = 2; f1[2] = 4; f2[0] = 1; f2[1] = 2; f2[2] = 4; f2[3] = 8; for (int i=3; i\u0026lt;100005; ++i) f1[i] = (0LL + f1[i-1] + f1[i-2] + f1[i-3])%int(1e9+7); for (int i=4; i\u0026lt;100005; ++i) f2[i] = (0LL + f2[i-1] + f2[i-2] + f2[i-3] + f2[i-4])%int(1e9+7); int ans = 1; int cur_ch = pressedKeys[0]; int cur_cnt = 1; for (int i=1; i\u0026lt;pressedKeys.size(); ++i) { if (pressedKeys[i] != cur_ch) { if (cur_ch == \u0026#39;7\u0026#39; || cur_ch == \u0026#39;9\u0026#39;) ans = 1LL *ans * f2[cur_cnt - 1] % int(1e9+7); else ans = 1LL *ans * f1[cur_cnt - 1] % int(1e9+7); cur_ch = pressedKeys[i]; cur_cnt = 1; } else { ++ cur_cnt; } } if (cur_ch == \u0026#39;7\u0026#39; || cur_ch == \u0026#39;9\u0026#39;) ans = 1LL * ans * f2[cur_cnt - 1] % int(1e9+7); else ans = 1LL * ans * f1[cur_cnt - 1] % int(1e9+7); return ans; } }; ","permalink":"https://liuchang0812.github.io/posts/tech/leetcode/leetcode2266/","summary":"爬楼梯的加强版本，分别提前生成三个字母和四个字母的 fib 数组，然后分组统计后相乘。代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26","title":"2266. 统计打字方案数"},{"content":"一本名字和封面看起来都非常像地摊文学的书，实际上却是“中共党史出版社”出版的关于知青的报告文学，内容包含了大量真实的知青故事，读来让人不禁唏嘘。\n一个人的命运在历史的长河里太过于脆弱。\n里面最触动的一段是：知青为了保留回城的资格，会同居而不结婚，生的孩子没有办法上户口。在允许回城后，只能将孩子托付给当地人。\n","permalink":"https://liuchang0812.github.io/posts/read/chenjie/","summary":"一本名字和封面看起来都非常像地摊文学的书，实际上却是“中共党史出版社”出版的关于知青的报告文学，内容包含了大量真实的知青故事，读来让人不禁唏","title":"读书笔记 | 尘劫: 知青畅想曲"},{"content":"会写点儿 Cpp/Python 的码农，了解一点儿分布式存储系统\n","permalink":"https://liuchang0812.github.io/about/","summary":"会写点儿 Cpp/Python 的码农，了解一点儿分布式存储系统","title":"ABOUT"},{"content":"Golang error 是一个包含了 Error() string 函数的接口，任何实现了 Error() string 的结构体都可以认为是 error 类型。\n1 2 3 4 5 // The error built-in interface type is the conventional interface for // representing an error condition, with the nil value representing no error. type error interface { Error() string } 对于简单场景，返回一个带字符串描述的 error 可以通过 return errors.New(\u0026quot;this is a err\u0026quot;) 来实现。其内部实现的机制为：定义了一个 errorString 的结构体，调用 Error() 的时候返回初始化时传入的字符串。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // New returns an error that formats as the given text. // Each call to New returns a distinct error value even if the text is identical. func New(text string) error { return \u0026amp;errorString{text} } // errorString is a trivial implementation of error. type errorString struct { s string } func (e *errorString) Error() string { return e.s } 对于稍微复杂的场景，如果希望返回的错误信息中包含格式化字符串，可以通过 fmt.Errorf 来实现。其内部的实现为：通过一个 Printer 生成字符串，对于不包含异常的情况，调用上述的 errors.New。否则，返回一个 wrapError 结构体，保存包含的子 error ，并可以通过 Unwrap 取出。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 func Errorf(format string, a ...any) error { p := newPrinter() p.wrapErrs = true p.doPrintf(format, a) s := string(p.buf) var err error if p.wrappedErr == nil { err = errors.New(s) } else { err = \u0026amp;wrapError{s, p.wrappedErr} } p.free() return err } type wrapError struct { msg string err error } func (e *wrapError) Error() string { return e.msg } func (e *wrapError) Unwrap() error { return e.err } https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully ","permalink":"https://liuchang0812.github.io/posts/tech/golang/error-impl/","summary":"Golang error 是一个包含了 Error() string 函数的接口，任何实现了 Error() string 的结构体都可以认为是 error 类型。 1 2 3 4 5 // The error built-in interface type is the conventional interface for // representing an error condition, with the nil value representing no error. type error interface { Error()","title":"golang | error 的内部实现"},{"content":"[]byte 和 string 有什么区别？类型转换需要拷贝数据吗？如何选择正确的类型？\n[]byte和string的类型字义非常类似，[]byte 比 string 多一个 cap 成员。string 在大多数的语言中都表示不可变字符串，[]byte 则是可以修改的数组分片。所以在做 []byte 和 string 转换的时候，如果只是简单的将指针复制，就相当于同一块内存同时有了可变和不可变引用，修改了 []byte 会影响到 string 的不可变性（rust 选手应该比较熟悉）。所以做类型转换时，会额外的有内存申请与数据拷贝动作。\n至于在编码的时候该选择哪个类型，可以参考 andybalholm 的回答：尽量使用 string ，除非要频繁修改字符串或者要与使用的接口保持一致。\nMy advice would be to use string by default when you're working with text. But use []byte instead if one of the following conditions applies: - The mutability of a []byte will significantly reduce the number of allocations needed. - You are dealing with an API that uses []byte, and avoiding a conversion to string will simplify your code. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 type slice struct { data uintptr len int cap int } type string struct { data uintptr len int } // ByteSliceFromString returns a NUL-terminated slice of bytes // containing the text of s. If s contains a NUL byte at any // location, it returns (nil, syscall.EINVAL). func ByteSliceFromString(s string) ([]byte, error) { if strings.IndexByte(s, 0) != -1 { return nil, syscall.EINVAL } a := make([]byte, len(s)+1) copy(a, s) return a, nil } refs https://syslog.ravelin.com/byte-vs-string-in-go-d645b67ca7ff\nhttps://cs.opensource.google/go/go/+/master:src/cmd/vendor/golang.org/x/sys/windows/syscall.go;l=40?q=slicetostring\u0026amp;ss=go%2Fgo\nhttps://stackoverflow.com/questions/10826651/when-to-use-byte-or-string-in-go\n","permalink":"https://liuchang0812.github.io/posts/tech/golang/byte-slice-vs-string/","summary":"[]byte 和 string 有什么区别？类型转换需要拷贝数据吗？如何选择正确的类型？ []byte和string的类型字义非常类似，[]byte 比 string 多一个 cap 成员。s","title":"golang | []byte 和 string 的区别与适用场景"}]