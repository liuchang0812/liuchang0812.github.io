[{"content":"强烈推荐，书的排版很好，翻译的也特别好。比较有意思的是前半部分，介绍了明代的世袭军户制度下，人们从想办法减少服役代价，到利用制度来进行套利的方法，以及制度对人们生活文化的影响。\n这本书是外国人写的，还有部分被删减的内容。有兴趣的可以看豆瓣上网友的整理。\n这本书介绍了群众面对制度时的几大策略：\n“优化处境”（strategies of optimization）：轮替、集中、补偿、代役（集中策略的延伸）。 “近水楼台”（strategies of proximity）：卫所军官和士兵利用自己在军事体制中的特殊地位参与非法贸易，浑水摸鱼。 “制度套利”（strategies of regulatory arbitrage）：被调入军屯的屯军擅长运用套利策略，借由军田与民田的差异渔利。 “诉诸先例”（strategies of precedent）：清初军户如何试图维护自己在明朝体制中享有的特权，或出于利益考量为旧体制招魂。（308-309） ","permalink":"https://liuchang0812.github.io/posts/read/2023-06-reading/","summary":"强烈推荐，书的排版很好，翻译的也特别好。比较有意思的是前半部分，介绍了明代的世袭军户制度下，人们从想办法减少服役代价，到利用制度来进行套利的","title":"2023 06 读书分享：被统治的艺术"},{"content":"《城乡中国》豆瓣 4/5 分，一本关于中国土地财政的书，介绍了从建国以后关于土地的法律法规变化以及各方尝试。内容挺有意思，但是因为是文章合订本，内容有重复，逻辑性不太流畅。一些有意思的点： 关于自由迁徙：中国第一版的宪法是有写公民有自由迁徙的权力，在文化大革命的时候又被删了。教员在最开始的时候是不同意宪法中有自由迁徙的。 关于土地市场化：土地不许买卖 \u0026ndash;\u0026gt; 土地可以依法转让，但是要国务院立法。\u0026ndash;\u0026gt;国务院规定城市土地国有，可以流转。农村土地归集体，却一直不立法。\u0026ndash;\u0026gt; 各地实点实验：挂钩、地票等。 \u0026ndash;\u0026gt; 城市扩市或者征地。 只有国有土地可以流转。在超额土地利益面前，不再是人人平等。农民无法享受这一波红利。深圳是100%土地城市化国有化，也是第一个学习香港立法拍卖土地的。在宪法修改时，曾打算所有土地国有，为了减小影响，后面修改为“城市土地一律国有，农村土地归集体所有”。 作者认为解决问题的方法是：还权赋能，农地入市。但我认为这很难实现，土地财政已经绑架了太多人太多东西。如果最开始就农地入市也许我们可以像欧美一样人人住上大 house，但是历史没有假如。 《王氏之死》豆瓣 3/5 分，漫长的余生中推荐的一本书，但是读来实在没什么意思，内容也比较少。可能是我的能力问题，没有读到精髓。 ","permalink":"https://liuchang0812.github.io/posts/read/2023-05/","summary":"《城乡中国》豆瓣 4/5 分，一本关于中国土地财政的书，介绍了从建国以后关于土地的法律法规变化以及各方尝试。内容挺有意思，但是因为是文章合订本，内容","title":"2023 05 读书分享：城乡中国、王氏之死"},{"content":"这本书主要包含两个部分，第一个部分介绍了清代行政体系下几个主要角色的方方面面，包括职责、如何认命监管、怎么获取陋规，第二个部分介绍清朝司法税务等主要部门的运行机制。\n前半本书阅读下来，感想就是“百姓苦啊，只要和官府打交道就要被所有角色剥削”。统治阶级也知道这些陋规的存在，但是默认了这些行为，甚至将其中一些陋规合法化，不然无法维持整个行政体系。\n司法体系\n州县官只能使用民事案件以及不超过笞杖或枷号的轻微刑事案件。判决不需要上级批准但是需要定期上报。 如果有错判，州县官要遭受同样的罪责 治安与保甲制度，发动群众与连坐制。\n辖区内的民户组织成牌（十户）、甲（百户）和保（千户）等基本治安单位，并指定牌头、甲长、保正或保长。[1]州县官每年会向每户人家签发一个门牌，上面列出户主的姓名、年龄、职业和该户其他成员的姓名，包括亲戚和仆婢。[2]只要家中有人员进出变动，户主就要向甲长汇报。甲长有责任在保甲簿中予以登记，并修正门牌。[3]通常，保甲簿一式两份，一份由甲长保存，另一份由州县官保存。甲乙两簿定期交换：甲簿由甲长根据甲内实际人口的变动修正后，呈交给州县官，州县官就将乙簿交还给甲长由其作相应改动，如此循环。这种方式确保了保甲记录的不断更新。[4]\n保甲制度同时适用于乡村和州城县城，所有居民都包括在保甲组织内，包括无业者、流配人犯、娼妓和其他受法律制裁者。[5]保甲制的基本功能，是要建立起缉查违法，特别是缉查强盗、土匪的治安组织网络。[6]有些州县官还借保甲制以推进道德教化之功效。[7]保甲制度背后的深层理念是：每个人的行动都难以逃过邻里乡亲之耳目；若将邻里居民组织起来，官方掌握所有民户登记资料，则陌生人及违法者必定难以在守法居民中隐藏。\n尽管设立常平仓的目的是造福穷人，但实际上它并未给穷人带来福利。首先，由于粮仓设在州城县城，居住偏远的乡民常常享受不到好处。 尽管法律有禁令，[11]但儒户、衙役和粮行老板仍常常勾结书吏，假造名籍大量购买官米，从其低廉的价格中获利。[12]粮仓书吏和衙役常常对到官仓购米的百姓勒索钱财，或者要求他们超量返还从官仓借去的粮食。[13]为了将陈年粮食清仓，有的州县官常强迫百姓购买陈粮，即使他们并不需要。[14]百姓更有一种负担，即州县官常常以低于市场的价格向本州县百姓购粮，并要售粮者自己将粮食从乡村运送到官仓。[15]因此，朝廷曾发布一条规定：补充官仓的粮食必须从邻县购置；只有本县和邻近州县之间没有水运的情况下，州县官才可以在自己辖区内购粮。\n有时候政策是好的，执行起来却问题很多。\n根据曾任县官的方大湜的经验，灾害勘查的过程往往充满罪恶的勾当。如果将这一事务交由书吏、保甲长来办理，他们就会从事各种贪污活动。[41]如果委托给士绅，又容易出现徇私舞弊的情况。同时，州县官亲自到各家各户查访又极端困难。[42]王凤生认为最好的办法是由村长登记受灾人口，由士绅核查，再由专员作进一步审查。\n中国士绅的一个重要特点是：他们是唯一能合法地代表当地居民社群与官吏共商地方事务、参与治理过程的群体。这一特权从未扩展到其他任何社群和组织。\n具备进入特权阶层的条件，与特权身份实际获得，二者之间是有差距的。财富和田产 身，不是士绅身份的充分条件。庶民地主，不论拥有多少土地，也不属于士绅群体。“ 绅”既不属于统治阶层，也不属于被统治阶层，他们属于一个中间阶级。[21]他们并未 入正式的政府，但却享有很高的威望、特权和统治阶级权力——这一事实将他们作为精英 普通大众区别开来。作为官僚集团的潜在候补成员，他们也可称作潜在的统治阶级。\n官绅不在当地司法管辖权之下，也不受常规司法程序的约束。未经皇帝的允许，官员 得受审讯和判决。\n只有财富与政治权力联结起来时，人们才能确保其自身和家庭的安宁。[21]这有助于 释为何人们渴望获得功名和当官。\n作为一个特权阶层，他们渴望维持现状，抵制任何可能危害既定社会秩序的力量。地 防务，这样一种需要强有力的权威和财力支撑的任务，自然就落到了士绅肩上，因为他 为地方百姓所尊敬和追随并可以接触政府官员。\n地方官吏既然不能跟士绅争辩附加费的合法性，又无力确立一个更高的折算率，就只 根据惯例按较低附加费率向士绅征税。为了弥补征税成本和衙门其他开支，官员只好将 收负担转嫁到不能据法抗争、无力保护自己的普通百姓头上。\n顾炎武才认定，官绅、学绅、书吏、衙役这些豁免徭役的群体，正是引起百姓苦难的 首。他认为，只有“废生员”才能缓解百姓的痛苦。\n学而优则仕\n","permalink":"https://liuchang0812.github.io/posts/read/2023-07/","summary":"这本书主要包含两个部分，第一个部分介绍了清代行政体系下几个主要角色的方方面面，包括职责、如何认命监管、怎么获取陋规，第二个部分介绍清朝司法税","title":"2023 07 读书分享：清代地方政府"},{"content":"漫长的余生 书名不好，书很不错。这种书名放在面前都可能不会被注意到。 作者希望用宫女王钟儿作为线索，介绍北魏的一段历史。但是实际读起来，感觉意义不大，不如直述。 之前对魏晋南北朝这段历史了解不多，读这本书还是比较吃力（人物名字太相似），但是北魏的历史还挺有意思。搜了一下国内有一部电视剧叫 胡笳汉月，可惜没有过审，被剪成了几集历史纪录片。 需要把主要人物的关系图整理一下，才能更好理解。 ^^子贵母死^^ 的制度真是残忍，本来是为了避免外戚乱权，却被几任皇太后利用来维持自己的地位。 %%{init: {'theme':'neutral'}}%% flowchart TD XiaoWD[孝文帝] FHH[冯皇后] CTH[常太后] WCD[文成帝] XianWD[献文帝] DFHH[大冯皇后] XFHH[小冯皇后] XWD[宣武帝] GZR[高照容] YX[元恂] subgraph 皇帝 WCD==长子==\u003eXianWD==长子==\u003eXiaoWD==次子==\u003eXWD XiaoWD==长子==\u003eYX end subgraph 皇后 CTH--选立--\u003eFHH FHH--侄女--\u003eDFHH FHH--侄女--\u003eXFHH DFHH--杀死--\u003eGZR end CTH--乳母--\u003eWCD FHH--乳母--\u003eXianWD FHH--杀死生母从小抚养--\u003eXiaoWD XiaoWD--皇后--\u003eDFHH XiaoWD--皇后--\u003eXFHH GZR--生母--\u003eXWD DFHH--抚养--\u003eXWD XFHH--抚养--\u003eYX 父母的语言 这本书的核心观点是小朋友3岁前接受到语言词汇对于智力发育有很大的影响。按照作者统计，经济差异大的家庭之间有3 kw的单词数差异。\n文章提到一个4T原则，还是很有道理的\nTune In 共情 Talk More 充分交流 Take Turns 交替交流 Turn off 关闭电子设备 书的逻辑性不太认可，表述也一般，可能和翻译有关，一般推荐\n","permalink":"https://liuchang0812.github.io/posts/read/2023-04/","summary":"漫长的余生 书名不好，书很不错。这种书名放在面前都可能不会被注意到。 作者希望用宫女王钟儿作为线索，介绍北魏的一段历史。但是实际读起来，感觉意义","title":"2023 04 读书分享：漫长的余生、父母的语言"},{"content":"小镇喧嚣：一个乡镇政治运作的演绎与阐释 推荐，华科大教授写的一本书，记录了在小镇调查的一年半期间遇到的事情，主要包括：镇政府如何处理上级检查，乡镇村干部如何收农业税，如何处理各种农村冲突上访等。\n文风不错，像读小说一样引人入胜。同时引用详细，可以学到大量不知道的知识。\n美丽新世界 一本反乌托邦世界的书，其中未来世界的设定很有意思。\n人类还通过基因工程被改造成几个等级，以便从事不同的工作。低等级的人类从事重复劳动，而他们因为智商低下，像动物一样被劳役而不会反抗。而高等级的人类，他们从小在睡眠中被催眠教育，不相信上帝，不相信爱情。人是通过试管培育的，没有父亲，没有母亲。“每个人都属于彼此。”所以男人可以和任何一个女性做爱，女性也可以和任何男性交往。他们没有嫉妒。没有排他的占有欲。A片高级到只要看的时候手扶把手，可以通过电磁波把感官感受直接作用于人体。而这些方式当然并不能消除人类所有的欲望而使人免于痛苦。当人有烦恼的时候，可以吃点“唆麻”，一种对人体无害的毒品。然后人就忘记烦恼，无忧无虑了。\n失去的三十年 介绍日本广场协定泡沫破裂相关历史和知识。这本书篇幅较小，内容也较少。看完之后留下的有印象的内容很少。后面有空再认真看一遍吧。\n","permalink":"https://liuchang0812.github.io/posts/read/2023-03-reading/","summary":"小镇喧嚣：一个乡镇政治运作的演绎与阐释 推荐，华科大教授写的一本书，记录了在小镇调查的一年半期间遇到的事情，主要包括：镇政府如何处理上级检查，","title":"2023 03 读书分享"},{"content":" 最近在咸鱼上入了一个 kindle oasis，体验比之前的 kindle paperwhite 好太多了，最近买得最值的东西了。争取可以多看书多写文字分享，锻炼一下自己。\n《置身事内》介绍中国经济相关知识 个人觉的非常不错的书，值得 5 星推荐。之前在微信读书上看过，这几天又抽空在 kindle oasis 上看了一遍，还是收获很大。\n前段部分介绍了中国这几十年来经济发展过程与其中遇到的问题与改革方法，比较体系化的介绍了为什么从“财政包干”到“分税制”改革，再到“国税地税合并”和“房地产”。也介绍了中国政府的运作方式。也介绍了“京东方”和“光伏“产业发展的历史。 后段部分宏观分析了债务、工业化、国际贸易等，相对我就不太感兴趣了。\n作者文笔十分流畅，引用清晰，而且每章都推荐了很多相关的书。\n《永久记录》斯诺登传记 斯诺登自己写的传记，介绍了小时候的成长经历，在美国国安局的工作经历，以及后来在 HK 发生的事情。\n3 星推荐吧。作者的一些思考还有些意思。\n《他改变了中国》江泽民传记 4 星推荐。江主席的人生智慧。值的认真读一下，可以了解到很多历史细节。\n","permalink":"https://liuchang0812.github.io/posts/read/2023-02-reading/","summary":"最近在咸鱼上入了一个 kindle oasis，体验比之前的 kindle paperwhite 好太多了，最近买得最值的东西了。争取可以多看书多写文字分享，锻炼一下自己。 《置身事内》介绍","title":"2023 02 读书分享"},{"content":"libco 协程，被分类到非对称协程。分类的方法是：\n对称协程（典型的如 golang 的 goroutine），一个协程 yield 后，执行机会不会直接返还到调用者，而是调度器来决定唤起哪个协程。 非对称协程（例如 libco ），一个协程 yield 后，会返还到调用者，继续执行调用者的函数。 非对称在于程序控制流转移到被调协程时使用的是 call/resume 操作，而当被调协程让出 CPU 时使用的却是 return/yield 操作。此外，协程间的地位也不对等，caller 与 callee 关系是确定的，不可更改的，非对称协程只能返回最初调用它的协程。\nhttps://zhuanlan.zhihu.com/p/51078499\n在 libco 的实现中，每个线程会有一个 stack 来维护当前的协程列表，调用 co_resume 则会压入一个协程，调用 co_yield 则会弹出一个协程（实际的实现是栈顶指针的加减）。\n所以，在实际使用过程中，如果涉及到复杂场景，需要用到 co_yield 来自己调度 libco 的协程。那么怎么来实现呢，有没有什么套路。我们可以参考这个自带例子来学习一下。\n因为需要自己调度协程，所以一般要把协程指针和对应任务信息封装到一个结构体中，同时使用一个 stack/queue 保存所有的协程（因为一个协程 yield 之后就找不到了，没办法自动继续执行）。\nstruct task_t // 一个任务结构体 { stCoRoutine_t *co; // 对应的协程指针 int fd; // 协程负责任务的参数 }; static stack\u0026lt;task_t*\u0026gt; g_readwrite; // 开一个全局变量来保存所有的任务 为了方便理解，可以先忽略例子中的多进程部分代码。代码先创建了若干个 readwrite_routine协程\nfor(int i=0;i\u0026lt;cnt;i++) { task_t * task = (task_t*)calloc( 1,sizeof(task_t) ); task-\u0026gt;fd = -1; // 特殊值 co_create( \u0026amp;(task-\u0026gt;co),NULL,readwrite_routine,task ); co_resume( task-\u0026gt;co ); // 压到 stack 中开始执行，跳转到下面的函数 } static void *readwrite_routine( void *arg ) { co_enable_hook_sys(); // hook read/write 等io调用走协程实现 task_t *co = (task_t*)arg; char buf[ 1024 * 16 ]; for(;;) { if( -1 == co-\u0026gt;fd ) // 第一次进来是 -1 特殊值，将 task 保存到 g_readwrite { g_readwrite.push( co ); co_yield_ct(); // 让出 cpu 到调用者，也就是主线程，继续创建协程。 } // 然后会进入到 accept_routine continue; int fd = co-\u0026gt;fd; // 从 accept_routine 切换回来，这个时候 fd 有值了 co-\u0026gt;fd = -1; // 标记为特殊值，下次循环会 yield 出去 for(;;) { // 任务逻辑 struct pollfd pf = { 0 }; pf.fd = fd; pf.events = (POLLIN|POLLERR|POLLHUP); co_poll( co_get_epoll_ct(),\u0026amp;pf,1,1000); int ret = read( fd,buf,sizeof(buf) ); if( ret \u0026gt; 0 ) { ret = write( fd,buf,ret ); } if( ret \u0026gt; 0 || ( -1 == ret \u0026amp;\u0026amp; EAGAIN == errno ) ) { continue; } close( fd ); break; } } return 0; } static void *accept_routine( void * ) { co_enable_hook_sys(); for(;;) { if( g_readwrite.empty() ) // g_readwrite 为空时，等待1s { struct pollfd pf = { 0 }; pf.fd = -1; poll( \u0026amp;pf,1,1000); continue; } struct sockaddr_in addr; //maybe sockaddr_un; memset( \u0026amp;addr,0,sizeof(addr) ); socklen_t len = sizeof(addr); int fd = co_accept(g_listen_fd, (struct sockaddr *)\u0026amp;addr, \u0026amp;len); if( fd \u0026lt; 0 ) { struct pollfd pf = { 0 }; pf.fd = g_listen_fd; pf.events = (POLLIN|POLLERR|POLLHUP); co_poll( co_get_epoll_ct(),\u0026amp;pf,1,1000 ); // co_accept/co_poll注册回调，在有数据的时候swap回来，然后让出 cpu，执行 co_eventloop continue; } if( g_readwrite.empty() ) // double check { close( fd ); continue; } SetNonBlock( fd ); task_t *co = g_readwrite.top(); // 取一个协程，分配这个 accept 的 fd co-\u0026gt;fd = fd; g_readwrite.pop(); co_resume( co-\u0026gt;co ); // 切换到改协程，继续执行 readwrite_routine } return 0; } 总结一下 使用 libco 自己调度协程的实现模式有：\n用一个全局队列保存所有的任务执行协程； 使用 task 结构体保存协程指针和任务参数； 任务执行协程初始化后压到协程队列，让出 cpu 给调用者； 任务分发协程在没有可用协程时（协程队列为空），等待任务协程空闲。有任务时，更新任务参数后唤醒执行协程。 ","permalink":"https://liuchang0812.github.io/posts/tech/os/libco-usage/","summary":"libco 协程，被分类到非对称协程。分类的方法是： 对称协程（典型的如 golang 的 goroutine），一个协程 yield 后，执行机会不会直接返还到调用者，而是调度器","title":"libco usage"},{"content":"Paxos 协议与工程实现 写在前面，我没有完整实现过 Paxos 协议，不敢保证下面描述的内容完全正确。本文主要是学习的笔记，如果有错误，十分欢迎指出，大家一起讨论学习。\n本文所有内容都是参考 PaxosStore 论文 《PaxosStore: High-availability Storage Made Practical in WeChat》\n概念定义 为了后续方便描述，我们先定义会用到的概念\nProposal 提议，包含提议号和提议值； Prepare 第一阶段 Proposer 发出的请求，包含一个提议号； Promise 第一阶段 Proposer 回应的消息，包含一个提议号和一个（如果有）已经 Accepted 的最大提仪； Accept 第二阶段 Proposer 发出的请求，包含一个提议号和一个提议值； Accepted 第二阶段 Proposer 回应的消息，包含一个提议号。也表示一个提议被一个该 Proposer 接受； Chosen 代表一个提议被大多数的 Proposer 接受，不会再发生改变； Proposer 提议成员； Acceptor 发送 Accepted 消息的成员； Learner 学习者，不参与 Paxos 投票过程。 与可以用代码语言描述，参考 链接\n// Prepare 请求，包含一个提议号 struct Prepare { int n; }; // 在收到大多数的 Promised 请求后，发出的 Accept 请求，包含一个提仪号以及一个值。 // 这个值是 Promised 中最大提议号的值，如果所有 promised 都没有返回值，则可以自己提出任意值。 // 对应到工程实现上，则代表这个位置已经被占了，可以再起一轮新 paxos struct Accept { int n; void *value; }; // n 承诺不 accept 小于 n 的 accept 请求，返回当时最大提议号对应的值。 struct Promised { int n; Accept *proposal = nullptr; }; // 如果满足承诺，返回最大的提议号 struct Accepted { int n; }; // paxos 成员会在内存中纪录的值，包括最大的提议号，以及对应的值。 class Acceptor { int last_n = 0; Accept *proposal = nullptr; }; Basic Paxos 协议 Basic Paxos 是理论上的最基础的一致性算法，作用是：多个（奇数）成员确定唯一一个值。\n算法分为两轮，第一轮 Prepare 请求会得到承诺后续不通过小于本次 Prepare.n 的提议，同时返回自己已经 accepted 的最大提议。第二轮 Accept 请求会带上上一轮收到的最大提议值（如果没有，则可以自己提出），每个 Acceptor 在不违背承诺的情况下更新本地状态。\n一个提仪一旦被大多数结果 accepted，就会被认为是 chosen。对于一个值来说，accepted 还是可以变的，chosen 的永远不会变。一组经典的 paxos 实例只能确定（chosen）一个值。\n算法的详细描述可以参考论文：\nPhase 1.\nA proposer selects a proposal number n and sends a prepare request with number n to a majority of acceptors.\nIf an acceptor receives a prepare request with number n greater than that of any prepare request to which it has already responded, then it responds to the request with a promise not to accept any more proposals numbered less than n and with the highest-numbered proposal (if any) that it has accepted.\nPhase 2.\nIf the proposer receives a response to its prepare requests (numbered n) from a majority of acceptors, then it sends an accept request to each of those acceptors for a proposal numbered n with a value v, where v is the value of the highest-numbered proposal among the responses, or is any value if the responses reported no proposals.\nIf an acceptor receives an accept request for a proposal numbered n, it accepts the proposal unless it has already responded to a prepare request having a number greater than n.\n注意细节：\nAccept 请求中的 value 是一阶段返回所有 promised 中 n 最大的那个值。是 promised→proposal.n 的 n，而不是 promised.n acceptor 上 accept 值还是会被修改的。 在提议被大多数通过的一瞬间，这个值就确定下来了，再也不会被修改。 对于证明的思路是这么一种思路：证明一个值 chosen 不会被修改，可以通过加强的方式。如果一个大于当前提仪号并且值不同的提仪，不会被发出。chosen 的值自然就不会被修改。\nMulti Paxos 实现方法 可以看到，Basic Paxos 算法只能确定一个值，同时要走两轮流程。为了在真实系统上实际使用起来，还需要做一些修改优化。\n我们可以在 Basic Paxos 上增加一个 Entry ID 的维度，每个 Entry 保存一个值。同时，可以在第 i 个 Entry 中携带上第 i+1 个 Entry 的 Prepare 信息：当 $E_i$ 被 chosen 时，同时认为 $E_i+1$ 已经完成了 prepare 流程。\n工程实现上的问题 论文只描述了 Paxos 算法的流程和证明，在实际实现上，还有很多细节要处理，例如怎么 CatchUp、怎么 GetALL以及一些细节的问题。\n写读读问题 写读读的问题场景：假设三机日志都commit到了Entry 100，然后机器 A执行 Entry 101 的二轮过程然后挂掉。这个时候会读到 100 的值。然后机器 A 恢复同步状态到 BC，后续就读到了 Entry 101。\n重复执行问题 重复执行的问题场景：机器 A 收到一个写请求，在执行完 Paxos 后被 chosen，然后发送响应给客户端。这个响应可能因为网络原因未发到或者超时。然后客户端超时后重发请求到机器 B。机器 B 重新跑一次 Paxos 过程，然后回复客户端。这儿更新过程就会执行两次，如果是有状态的更新就会有问题。\n所以要让请求幂等，方法就是在请求上带上 request ID， svr 端检查 request ID 。\nThe request ID is generated by the client and sent together with the write request, and checked by the PaxosStore node to detect potential duplication of actual request handling.\nPlogKV 实现问题 文章同时提到了一个 PaxosLog for KV Data，可以优化掉 DB 部分的成本。那么正常的plog存储的key应该是entityid和entryid？怎么用key来查询？\n答案是只维护两个entry，一个最新chosen，一个pending。每个 key 都是一个 paxos 实例。\n参考 https://sf-zhou.github.io/paxos/paxos_store_03_consensus.html http://www.vldb.org/pvldb/vol10/p1730-lin.pdf ","permalink":"https://liuchang0812.github.io/posts/tech/os/paxos-note/","summary":"Paxos 协议与工程实现 写在前面，我没有完整实现过 Paxos 协议，不敢保证下面描述的内容完全正确。本文主要是学习的笔记，如果有错误，十分欢迎指出，大家一起讨","title":"Paxos Algorithm Note"},{"content":"cgroup 全称是 control group，是 linux 下的一个内核模块，用来控制进程的系统资源使用。例如可以限制进程 cpu 使用量、内存使用量等。比如知名开源软件 docker 就是基于 cgroup 来限制容器资源使用，使用 namespace 隔离进程空间。\ncgroup 分为 v1 和 v2 两个版本。常用的子系统有：\ncpu/cpuset/cpuacct：限制和统计 cpu 的用量 memory：限制内存的用量 blkio：限制块设备的用量，但是只能限制 direct io 使用方式 cgroup 基于 linux vfs 技术，将 cgroup 映射到一个目录。系统管理员通过在目录下创建文件的方式来使用 cgroup。默认情况下，cgroup 映射的目录为 /sys/fs/cgroup ，该目录下每个目录对应一个子系统。系统管理员可以在子系统目录中新建树状目录来设置 cgroup 限制，例如 /sys/fs/cgroup/cpu/g1 代表一类进程限制。\n➜ ~ ls /sys/fs/cgroup blkio cpu cpuacct cpu,cpuacct cpuset devices freezer hugetlb memory net_cls oom perf_event pids systemd 除了使用 /sys/fs/cgroup ，还可以通过 cgcreate 、 cgexec 等命令来使用 cgroup。例如\n# 使用 /sys/fs/cgroup/cpu/test_cpu 来限制 ./test 进程运行 cgexec -g cpu:test_cpu ./test ","permalink":"https://liuchang0812.github.io/posts/tech/os/cgroup/","summary":"cgroup 全称是 control group，是 linux 下的一个内核模块，用来控制进程的系统资源使用。例如可以限制进程 cpu 使用量、内存使用量等。比如知名开源软件 docker 就是基于 cgroup","title":"cgroup usage"},{"content":" 我们以 C++11 的 API 接口定义来描述\n大家在编写多线程类的程序时，会用到信号量 condition_variable，有没有疑惑过为什么 cv 这类接口，在调用 wait/notify 时候还需要用一个 mutex。\n为什么 cv.wait() 需要用 mutex 保护？ 常见的 cv 代码实现类似下方，包含三个部分：检查条件是否满足；如果不满足等待到满足；等待到满足后执行逻辑。\nstd::unique_lock\u0026lt;std::mutex\u0026gt; lock(cv_m); while (!cond_ok()) { // 1. 检查条件是否满足 wait(lock); // 2. 等待信号 } // do somethings with cond // 3. 执行逻辑 如果没有一个锁保护这三个部分，会出现两种情况：\n在第一部分检查条件不满足，准备进行第二部分 wait信号时，另一个线程达到了信号条件并 signal ，然后执行到 wait 。这个时候 wiat 就永远挂在这儿了。 在第二部分执行完成后，认为已经达到条件，准备执行第三部分的业务逻辑。另一个线程修改了条件。第三部分执行的假设是条件已经满足，违反了假设，业务逻辑可能会有问题。 所以一般会通过一个 mutex 将上述三个部分看起一个原子操作，将检查条件是否完成与等待信号量同时执行。其它线程如果 signal 信号，一定是在检查条件之前或者wait之后。\n附录 lock-and-condition-variable cppreference ","permalink":"https://liuchang0812.github.io/posts/tech/os/why-conv-need-a-mutex/","summary":"我们以 C++11 的 API 接口定义来描述 大家在编写多线程类的程序时，会用到信号量 condition_variable，有没有疑惑过为什么 cv 这类接口，在调用","title":"Why Does Conv Need a Mutex"},{"content":"书名：1984 政治小说，推荐指数 4 颗星\n小说虚构了一个极权社会，介绍了为真理部工作的外党成员温斯顿的故事。在极权社会下，到处都有电屏的监视。人们每天还要进行仇恨会的活动。对于不认同老大哥统治的思想有“问题”的人，会被思想警察完全从社会上抹去。\n主人公为真理部工作，工作内容是篡改历史，抹去被消失人的纪录。小说中主要分为两部分：一部分是认识女主，和女主发生的故事。另一部分则是被思想警察钓鱼执法，被惨烈的思想改造。\n书名：大逃港 政治向的报告文学，推荐指数 4 颗星\n这本书主要介绍了在建国后深圳人民群众逃港的故事。稍微的有点儿故事会写法。人民不管姓资还是姓社，只关心能不能吃饱肚子过上好日子，于是用脚投票，冒着生命危险去逃港。在改革开放后，则大量减少了逃港行为。\n书名：风格的要素 关于英语写作的小册子，推荐指数 2 颗星\n","permalink":"https://liuchang0812.github.io/posts/read/2022-05-reading/","summary":"书名：1984 政治小说，推荐指数 4 颗星 小说虚构了一个极权社会，介绍了为真理部工作的外党成员温斯顿的故事。在极权社会下，到处都有电屏的监视。人","title":"2022 05 读书分享"},{"content":"记忆化搜索，刚好卡过去\n执行用时：1964 ms, 在所有 C++ 提交中击败了 5.08% 的用户\nint mem[100][100][100][100]; class Solution { public: // 0 unknow // 1 true // 2 false bool dfs(const vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; grid, int x1, int y1, int x2, int y2) { if (x1 \u0026gt;= grid.size() || x2 \u0026gt;= grid.size() || y1\u0026gt;=grid[0].size() || y2 \u0026lt; 0 || x2 \u0026lt; 0 || x1 \u0026gt; x2 || y1 \u0026gt; y2) return false; if ((x2 - x1 + y2 - y1)%2==0) return false; if (mem[x1][y1][x2][y2] != 0) { return mem[x1][y1][x2][y2] == 1; } if ( x2 - x1 + y2 - y1 == 1 \u0026amp;\u0026amp; grid[x1][y1] == \u0026#39;(\u0026#39; \u0026amp;\u0026amp; grid[x2][y2] == \u0026#39;)\u0026#39;) { mem[x1][y1][x2][y2] = 1; return true; } if (grid[x1][y1] == \u0026#39;(\u0026#39; \u0026amp;\u0026amp; grid[x2][y2] == \u0026#39;)\u0026#39;){ bool tmp = dfs(grid, x1+1, y1, x2-1, y2) || dfs(grid, x1+1, y1, x2, y2-1) || dfs(grid, x1, y1+1, x2-1, y2) || dfs(grid, x1, y1+1, x2, y2-1); if (tmp) { mem[x1][y1][x2][y2] = 1; return true; } for (int i=x1; i\u0026lt;=x2; ++i) for (int j=y1; j\u0026lt;=y2; ++j) { if (i == x1 \u0026amp;\u0026amp; j==y1) continue; if (i == x2 \u0026amp;\u0026amp; j==y2) continue; if ((dfs(grid, x1, y1, i, j) \u0026amp;\u0026amp; dfs(grid, i, j+1, x2, y2))) { mem[x1][y1][x2][y2] = 1; return true; } if (dfs(grid, x1, y1, i, j) \u0026amp;\u0026amp; dfs(grid, i+1, j, x2, y2)) { mem[x1][y1][x2][y2] = 1; return true; } } mem[x1][y1][x2][y2] = 2; return false; } else { mem[x1][y1][x2][y2] = 2; return false; } } bool hasValidPath(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; grid) { int row = grid.size(); int col = grid[0].size(); if ((row + col)%2==0) return false; if ( grid[0][0] == \u0026#39;)\u0026#39; || grid[row - 1][col - 1] == \u0026#39;(\u0026#39;) return false; memset(mem, 0, sizeof mem); return dfs(grid, 0, 0, row-1, col -1); } }; 题解里面有一个写法很好，可以学习一下\nclass Solution { public: bool hasValidPath(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; \u0026amp;grid) { int m = grid.size(), n = grid[0].size(); if ((m + n) % 2 == 0 || grid[0][0] == \u0026#39;)\u0026#39; || grid[m - 1][n - 1] == \u0026#39;(\u0026#39;) return false; // 剪枝 bool vis[m][n][(m + n + 1) / 2]; memset(vis, 0, sizeof(vis)); function\u0026lt;bool(int, int, int)\u0026gt; dfs = [\u0026amp;](int x, int y, int c) -\u0026gt; bool { if (c \u0026gt; m - x + n - y - 1) return false; // 剪枝：即使后面都是 \u0026#39;)\u0026#39; 也不能将 c 减为 0 if (x == m - 1 \u0026amp;\u0026amp; y == n - 1) return c == 1; // 终点一定是 \u0026#39;)\u0026#39; if (vis[x][y][c]) return false; // 重复访问 vis[x][y][c] = true; c += grid[x][y] == \u0026#39;(\u0026#39; ? 1 : -1; return c \u0026gt;= 0 \u0026amp;\u0026amp; (x \u0026lt; m - 1 \u0026amp;\u0026amp; dfs(x + 1, y, c) || y \u0026lt; n - 1 \u0026amp;\u0026amp; dfs(x, y + 1, c)); // 往下或者往右 }; return dfs(0, 0, 0); } }; ","permalink":"https://liuchang0812.github.io/posts/tech/leetcode/2267/","summary":"记忆化搜索，刚好卡过去 执行用时：1964 ms, 在所有 C++ 提交中击败了 5.08% 的用户 int mem[100][100][100][100]; class Solution { public: // 0 unknow // 1 true // 2 false bool dfs(const vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; grid, int x1, int y1, int x2, int y2) { if (x1 \u0026gt;= grid.size() || x2 \u0026gt;=","title":"2267. 检查是否有合法括号字符串路径"},{"content":"爬楼梯的加强版本，分别提前生成三个字母和四个字母的 fib 数组，然后分组统计后相乘。代码如下：\nclass Solution { public: int countTexts(string pressedKeys) { int f1[100005]; int f2[100005]; memset(f1, 0, sizeof f1); memset(f2, 0, sizeof f2); f1[0] = 1; f1[1] = 2; f1[2] = 4; f2[0] = 1; f2[1] = 2; f2[2] = 4; f2[3] = 8; for (int i=3; i\u0026lt;100005; ++i) f1[i] = (0LL + f1[i-1] + f1[i-2] + f1[i-3])%int(1e9+7); for (int i=4; i\u0026lt;100005; ++i) f2[i] = (0LL + f2[i-1] + f2[i-2] + f2[i-3] + f2[i-4])%int(1e9+7); int ans = 1; int cur_ch = pressedKeys[0]; int cur_cnt = 1; for (int i=1; i\u0026lt;pressedKeys.size(); ++i) { if (pressedKeys[i] != cur_ch) { if (cur_ch == \u0026#39;7\u0026#39; || cur_ch == \u0026#39;9\u0026#39;) ans = 1LL *ans * f2[cur_cnt - 1] % int(1e9+7); else ans = 1LL *ans * f1[cur_cnt - 1] % int(1e9+7); cur_ch = pressedKeys[i]; cur_cnt = 1; } else { ++ cur_cnt; } } if (cur_ch == \u0026#39;7\u0026#39; || cur_ch == \u0026#39;9\u0026#39;) ans = 1LL * ans * f2[cur_cnt - 1] % int(1e9+7); else ans = 1LL * ans * f1[cur_cnt - 1] % int(1e9+7); return ans; } }; ","permalink":"https://liuchang0812.github.io/posts/tech/leetcode/leetcode2266/","summary":"爬楼梯的加强版本，分别提前生成三个字母和四个字母的 fib 数组，然后分组统计后相乘。代码如下： class Solution { public: int countTexts(string pressedKeys) { int f1[100005]; int f2[100005]; memset(f1, 0, sizeof f1); memset(f2, 0, sizeof f2); f1[0] = 1; f1[1] = 2;","title":"2266. 统计打字方案数"},{"content":"尘劫: 知青畅想曲 一本名字和封面看起来都非常像地摊文学的书，实际上却是“中共党史出版社”出版的关于知青的报告文学，内容包含了大量真实的知青故事，读来让人不禁唏嘘。\n一个人的命运在历史的长河里太过于脆弱。\n里面最触动的一段是：知青为了保留回城的资格，会同居而不结婚，生的孩子没有办法上户口。在允许回城后，只能将孩子托付给当地人。\n","permalink":"https://liuchang0812.github.io/posts/read/2022-04-reading/","summary":"尘劫: 知青畅想曲 一本名字和封面看起来都非常像地摊文学的书，实际上却是“中共党史出版社”出版的关于知青的报告文学，内容包含了大量真实的知青故事","title":"2022 04 读书分享"},{"content":"会写点儿 Cpp/Python 的码农，了解一点儿分布式存储系统\n","permalink":"https://liuchang0812.github.io/about/","summary":"会写点儿 Cpp/Python 的码农，了解一点儿分布式存储系统","title":"ABOUT"},{"content":"Golang error 是一个包含了 Error() string 函数的接口，任何实现了 Error() string 的结构体都可以认为是 error 类型。\n// The error built-in interface type is the conventional interface for // representing an error condition, with the nil value representing no error. type error interface { Error() string } 对于简单场景，返回一个带字符串描述的 error 可以通过 return errors.New(\u0026quot;this is a err\u0026quot;) 来实现。其内部实现的机制为：定义了一个 errorString 的结构体，调用 Error() 的时候返回初始化时传入的字符串。\n// New returns an error that formats as the given text. // Each call to New returns a distinct error value even if the text is identical. func New(text string) error { return \u0026amp;errorString{text} } // errorString is a trivial implementation of error. type errorString struct { s string } func (e *errorString) Error() string { return e.s } 对于稍微复杂的场景，如果希望返回的错误信息中包含格式化字符串，可以通过 fmt.Errorf 来实现。其内部的实现为：通过一个 Printer 生成字符串，对于不包含异常的情况，调用上述的 errors.New。否则，返回一个 wrapError 结构体，保存包含的子 error ，并可以通过 Unwrap 取出。\nfunc Errorf(format string, a ...any) error { p := newPrinter() p.wrapErrs = true p.doPrintf(format, a) s := string(p.buf) var err error if p.wrappedErr == nil { err = errors.New(s) } else { err = \u0026amp;wrapError{s, p.wrappedErr} } p.free() return err } type wrapError struct { msg string err error } func (e *wrapError) Error() string { return e.msg } func (e *wrapError) Unwrap() error { return e.err } https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully ","permalink":"https://liuchang0812.github.io/posts/tech/golang/error-impl/","summary":"Golang error 是一个包含了 Error() string 函数的接口，任何实现了 Error() string 的结构体都可以认为是 error 类型。 // The error built-in interface type is the conventional interface for // representing an error condition, with the nil value representing no error. type error interface { Error() string } 对于简","title":"golang | error 的内部实现"},{"content":"[]byte 和 string 有什么区别？类型转换需要拷贝数据吗？如何选择正确的类型？\n[]byte和string的类型字义非常类似，[]byte 比 string 多一个 cap 成员。string 在大多数的语言中都表示不可变字符串，[]byte 则是可以修改的数组分片。所以在做 []byte 和 string 转换的时候，如果只是简单的将指针复制，就相当于同一块内存同时有了可变和不可变引用，修改了 []byte 会影响到 string 的不可变性（rust 选手应该比较熟悉）。所以做类型转换时，会额外的有内存申请与数据拷贝动作。\n至于在编码的时候该选择哪个类型，可以参考 andybalholm 的回答：尽量使用 string ，除非要频繁修改字符串或者要与使用的接口保持一致。\nMy advice would be to use string by default when you're working with text. But use []byte instead if one of the following conditions applies: - The mutability of a []byte will significantly reduce the number of allocations needed. - You are dealing with an API that uses []byte, and avoiding a conversion to string will simplify your code. type slice struct { data uintptr len int cap int } type string struct { data uintptr len int } // ByteSliceFromString returns a NUL-terminated slice of bytes // containing the text of s. If s contains a NUL byte at any // location, it returns (nil, syscall.EINVAL). func ByteSliceFromString(s string) ([]byte, error) { if strings.IndexByte(s, 0) != -1 { return nil, syscall.EINVAL } a := make([]byte, len(s)+1) copy(a, s) return a, nil } refs https://syslog.ravelin.com/byte-vs-string-in-go-d645b67ca7ff\nhttps://cs.opensource.google/go/go/+/master:src/cmd/vendor/golang.org/x/sys/windows/syscall.go;l=40?q=slicetostring\u0026amp;ss=go%2Fgo\nhttps://stackoverflow.com/questions/10826651/when-to-use-byte-or-string-in-go\n","permalink":"https://liuchang0812.github.io/posts/tech/golang/byte-slice-vs-string/","summary":"[]byte 和 string 有什么区别？类型转换需要拷贝数据吗？如何选择正确的类型？ []byte和string的类型字义非常类似，[]byte 比 string 多一个 cap 成员。s","title":"golang | []byte 和 string 的区别与适用场景"}]