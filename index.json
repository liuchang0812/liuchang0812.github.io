[{"content":"会写点儿 Cpp/Python 的码农，了解一点儿分布式存储系统\n","permalink":"https://www.liuchang0812.com/about/","summary":"\u003cp\u003e会写点儿 Cpp/Python 的码农，了解一点儿分布式存储系统\u003c/p\u003e","title":"ABOUT"},{"content":" 语言模型和词向量 今天在看一本关于 GPT 入门的书，学习了关于语言模型和词向量的部分。这里以外行小白的视角来介绍一下这两个东西。\n1. 语言模型：从规则到统计 语言模型的目标是让计算机“理解”人类语言，进而完成文本补全等任务。这里的“理解”并非真正的认知，而是通过概率预测下一个词的可能性。\n早期有两种思路：\n规则系统：人工编写语法规则。例如，规定“名词后面可能接动词”。但中文语法复杂，规则难以穷举，效果很差。 统计模型：从数据中学习规律。例如，给定前 N 个词，统计下一个词的概率分布。这就是 N-gram 模型 的核心思想。 以中文为例，若用 2-gram 模型，训练时需要将文本切分为词语序列（如鲁迅的小说会被分成“鲁迅”“的”“小说”等词），然后统计词频。例如，若语料中出现“鲁迅的小说”100次，“小说的年代”50次，则“鲁迅”后接“的”的概率为 100/(100+50) ≈ 67%。通过这种方式，模型可以模拟鲁迅的风格生成文本。\n2. 词向量革命：Word2Vec 与 CBOW 词向量是将词语映射到低维向量的技术，经典实现是 Word2Vec 的 CBOW（Continuous Bag of Words）模型。它的核心思想是：通过上下文预测目标词。\n假设我们有一个包含 7 个词的小语料库（如 [\u0026ldquo;我\u0026rdquo;, \u0026ldquo;爱\u0026rdquo;, \u0026ldquo;北京\u0026rdquo;, \u0026ldquo;天安门\u0026rdquo;, \u0026ldquo;天安\u0026rdquo;, \u0026ldquo;门\u0026rdquo;, \u0026ldquo;的\u0026rdquo;]），目标是训练一个 2 维的词向量。具体步骤如下：\n数据准备：将每个词转为 one-hot 编码（长度为 7）。例如，“北京”对应 [0,0,1,0,0,0,0]。 输入上下文：CBOW 的输入是目标词的上下文词。例如，若窗口大小为 2，目标词“爱”的上下文是“我”和“北京”。 嵌入层：将两个 one-hot 向量映射到 2 维空间，得到稠密向量（如 [0.2, 0.8] 和 [0.6, 0.4]）。 预测目标词：将上下文向量平均后输入全连接层，输出概率分布（如预测“天安门”的概率最高）。 训练完成后，嵌入矩阵的每一行对应一个词的向量。虽然高维空间中的语义关系无法直接解释，但相似词（如“猫”和“狗”）往往距离较近。例如，在理想情况下，可能观察到类似 国王 - 男人 + 女人 ≈ 王后 的语义运算，但这高度依赖训练数据和模型规模。\n3. 争议与局限 数据依赖性：词向量的质量严重依赖语料库。若数据量不足，模型可能学到错误关联（如“医生 - 男性 + 女性 = 护士”）。 语义黑箱：低维向量中的“语义方向”是数学推导的结果，而非明确的人类定义属性。 尽管如此，词向量仍是自然语言处理的重要基石。后续的 Transformer、BERT 等模型，在此基础上进一步提升了语言理解的深度。\n以上是我的学习笔记，欢迎指正！\n原文\n今天在看一本关于 GPT 入门的书，学习了关于语言模型和词向量的部分。这儿以外行小白的视角来介绍一下这两个东西。\n首先是语言模型，也就是怎么对人类语言模型建模，让计算机可以理解人类的语言。这儿的“理解”不一定是要真的理解，而是计算机可以完成文本补全之类的任务。第一个选择就是规则系统，把人类语言的语法作为规则编码进去。可想而知，这个很难做，效果也不好。第二个选择则是从概率统计的角度来看，计算机只要知道：给定 N 个单词，知道下一个单词可以为哪些单词，它们各自的概率是多少。\n所以就有了 N-GRAM 模型，用前 N 个单词作为前缀来判定下一个单词的概率。这个比较容易理解，训练过程也很直观了。你可以拿一个语料，比如鲁迅的小说，把他们按字切分后，每 N+1 个字生成一个 \u0026lt;C1, C2, … Cn, Cn+1\u0026gt; 元素，然后统计他们出现的次数。之后就可以模拟鲁迅生成文字。\n关于词向量，当年 word2vec 特别火。它能实现词汇的加减法。比如说： 国王 - 男人 + 女人 = 王后。 它的原理是什么呢？\n以其中的 CBOW 算法为例子，假设我们只有 7 个单词的文本库， 训练一个 2 维的词向量。 我们首先把文本库生成训练数据，对于每 N 个临近词生成：\u0026lt;W1, W2\u0026gt; 的元素，再用 one-shot 和单词下标来替换 W1 W2 得到类似 \u0026laquo;0, 0, 0, 1, 0, 0, 0\u0026gt;, 3\u0026gt; 的数据。 这儿 W1 下标为 4， W2 下标为 3。然后用一个简单的神经网络，这个网络的一层参数会是 72 的矩阵，输出一个 softmax 的 17 的矩阵。 这儿 \u0026lt;0, 0, 0, 1, 0, 0, 0\u0026gt; 作为网络输入， 3 作为答案来训练网络，最后就能得到 7*2 的权重矩阵。这个矩阵也就是这 7 个单词的词向量。 把它们画到图上，就会发现相关的词离得近，不相关的词离得远。\n本质上应该是：把文本人为切分生成了训练集，他们之间可能有种数据关系，通过神经网络的训练找到在指定维度向量上的表示。如果数据量够大，维度够多，每一维可能会对应到一个属性：比如是不是颜色，是不是生活物品。\n这个部分感觉还是挺简单优美且神奇的。我这儿介绍的比较外行，大家有兴趣可以查阅相关的文章。\n","permalink":"https://www.liuchang0812.com/posts/tech/ai/word2vec/","summary":"语言模型和词向量笔记， deepseek 优化版","title":"语言模型和词向量"},{"content":"这是一本关于陈虻的书，看到微信读书上朋友称之为神作，就读了一下。我也非常推荐。\n陈虻感觉是一个充满了大智慧喜欢思考表达能力很强的人，对于怎么做纪录片有自己特别深刻的思考，自己 100% 的投入到这个事情中，也做出了很多成就。\n我在审节目的时候，对自己有两个基本的要求：第一，不能说不好，只能说怎么样更好；第二，不是告诉你怎么改，而是激发你自己修改的欲望。\n一个创作者怎样变得成熟？陈虻经常挂在嘴边的叮嘱：你的视角有多宽，你观察一个事物的深度就有多深。当你的思维打开的时候，你就走向成熟。\n我们相信教育学的一个原理：自我教育所取得的效果胜于他人枯燥乏味的说教。\n你的片子不是只给我看，你是给所有的观众看的，你能把所有的理由解释给他们吗？那之后，我学会了不再给自己的错误寻找借口。\n为什么不饶人，就因为他接受信息的方式是错误的，并不是因为他不尊重我，而是因为他在听我说话的时候，老在寻找我的信息跟他的信息相同的部分，而不是寻找我的信息跟他的信息不同的部分。\n我感觉我们应该像他一样，多思考多输出，对事业百分百的投入。\n","permalink":"https://www.liuchang0812.com/posts/read/250324-chenmang/","summary":"东方时空制片人陈虻的一些话和思考","title":"《不要因为走得太远而忘记为什么出发》"},{"content":"单伟健博士的自传，内容主要包含了他从小在北京生活上学，到文革闹革命的见闻，然后到内蒙古戈壁劳作。之后以工农兵身份到对外贸易大学读书，毕业之后到美国读博任教的经历。\n时刻准备着，浪费时间就是对自己的谋杀。当机会来临的时候要抓住，不能因为没有准备而错失机会。 干一行爱一行，任何事情都要做好。 遇到问题多思考，从目标和对方角度考虑怎么解决。 深入群众和所有人搞好关系，人脉非常重要。 建议读英文或者繁体版本。简体版本删减了太多内容。\n","permalink":"https://www.liuchang0812.com/posts/read/25-03-out-of-the-gobi/","summary":"从戈壁滩走到美国，我是如何成为沃顿商学院教授的","title":"《走出戈壁》 单伟健"},{"content":"单伟健讲述收购韩国第一银行的故事，全文可分为收购银行、改造银行和出售银行三个部分。其中第一部分篇幅最长，详细讲述了长达两年的谈判过程。由于作者有记录日记的习惯，文中对细节的描写尤为具体。\n通过这个故事可以学习金融领域相关知识，了解专业谈判技巧，以及如何将破产银行改造为优质资产的操作方法。\n其中若干细节颇具启示意义：\n单博士无论工作多繁忙，始终坚持每日晨跑10公里 国有资产处置官员承受巨大舆论压力，宁愿牺牲部分收益也要平息民族主义情绪。为规避未来追责风险，主动要求引入审查机制 人性立场难免影响叙事，作者存在选择性美化倾向。例如书中强调主动捐赠数千万善举，却隐去了此举实为平息因避税问题引发的民众不满这一背景事实 ","permalink":"https://www.liuchang0812.com/posts/read/money-game/","summary":"想知道怎么收购一家银行吗？","title":"金钱博弈 单伟健"},{"content":"偶然在微信读书上看到这本书，作者是写了红色的起点那本书的叶永烈。按照时间顺序介绍了陈云的一生，写的还不错，很推荐。\n总的来说，前半部分比较精彩一些，了解很多革命早期的事迹。后半部分很多是已经知道的事情。\n","permalink":"https://www.liuchang0812.com/posts/read/chen-yun/","summary":"\u003cp\u003e偶然在微信读书上看到这本书，作者是写了红色的起点那本书的叶永烈。按照时间顺序介绍了陈云的一生，写的还不错，很推荐。\u003c/p\u003e\n\u003cp\u003e总的来说，前半部分比较精彩一些，了解很多革命早期的事迹。后半部分很多是已经知道的事情。\u003c/p\u003e","title":"陈云传"},{"content":"LSP 是 VSCode 定义的一个语言无关的协议，提供代码解析补全等功能。本文以 leveldb 为例，介绍一下怎么通过 LSP 来更方便的阅读代码。\n首先，我们需要下载代码，并生成 compile_commands.json 文件，clangd 会通过这个文件知道整个项目是如何编译的。\ngit clone https://github.com/google/leveldb.git cd leveldb/ git submodule update --init mkdir build cd build cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=1 .. 然后，我们就可以使用 VSCode 来阅读代码了，将鼠标放在变量名上，可以很容易的看到定义。可以任意的跳转定义和实现。可以方便的看到有哪些子类，有哪些地方调用了函数接口。\n也可以方便的查看 Call Hierarchy 和 Type Hierarchy。\nCall Hierarchy 有哪些地方调用了这个方法 Type Hierarchy 有哪些子类 可以很方便的看到传参的含义。\n","permalink":"https://www.liuchang0812.com/posts/tech/read-code-vscode/clangd/","summary":"\u003cp\u003eLSP 是 VSCode 定义的一个语言无关的协议，提供代码解析补全等功能。本文以 leveldb 为例，介绍一下怎么通过 LSP 来更方便的阅读代码。\u003c/p\u003e\n\u003cp\u003e首先，我们需要下载代码，并生成 \u003ccode\u003ecompile_commands.json\u003c/code\u003e 文件，clangd 会通过这个文件知道整个项目是如何编译的。\u003c/p\u003e","title":"现代化的源码阅读方法"},{"content":"使用状态机思路解决一个并行问题。\n题目可以描述为：进程A每轮循环产生一个 H，进程 B 每轮循环产生一个 O，需要保证每产生 3 个元素时都由 2 个 H 和 1 个 O 组成。\n朴素的解法：思考哪些数据需要放到临界区，比如产生了几个 H 和 几个 O，当自己的职责完成后，检查是否 H20 了，如果未满足就 wait 或者跳出（只生产一个 H 时）。当满足 H20 时就激活信号量，重置状态。\n上面的代码写起来还是比较繁琐的，考虑一下用一个状态机来描述这个问题。状态机如下，当状态为 -1 时，线程应该被阻塞。整个程序只需要纪录一个当前状态，代码简单逻辑清晰。\nState H O 0 {} 1 4 1 H 3 2 2 HO 0 -1 3 HH -1 0 4 O 2 -1 ","permalink":"https://www.liuchang0812.com/posts/tech/leetcode/state-machine-in-concurrency/","summary":"\u003cp\u003e使用状态机思路解决一个并行\u003ca href=\"https://leetcode.cn/problems/building-h2o\"\u003e问题\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e题目可以描述为：进程A每轮循环产生一个 H，进程 B 每轮循环产生一个 O，需要保证每产生 3 个元素时都由 2 个 H 和 1 个 O 组成。\u003c/p\u003e","title":"并发编程中的状态机"},{"content":"最近主要读了《民主的细节》《芯片战争》和新出的《Elon Musk》几本书。《芯片战争》是在飞机上快速翻了一遍。《民主的细节》是因为前段时间《巨变第二天》特别火，国内还买不到，所以找了一下作者其它著作。《Elon Musk》则是在公司读书活动上白嫖的。\n芯片战争 推荐大家读一读，可以快速浏览了解到芯片行业的发展过程。一是可以浅浅的了解到芯片技术和难点，现在的光刻机的难度相当“在地球上用激光打到月球上的一枚硬币”、“制作一个放大到地球大小也没有大坑洼的透镜”。二是了解芯片发展过程中各家公司和中美苏的发展历史和取舍，这儿中文版有删减。三是台湾台积电的芯片代工，有点儿像是计算机分层。在台积电之前如果要生产芯片要自己搞整个完整的流程，台积电则是专注在生产这一层，其它公司专注在设计芯片，把整个芯片流程解耦了。如果现在你要创业搞芯片，可以不用再自己建厂、购买光刻机、培训员工等。\nElon Musk 新出的一本马斯克传，挺有意思的。天才都是偏执的，故事的流程都是：提出一个不可能的目标，定一个不可能的deadline，你不听musk的就开除，然后 musk 深入一线对每个细节都关注，然后取得巨大的成功。\n民主的细节 期望很高，实际上很失望。以为作者是高校教授，这本书会是偏理论引用详实的那类。实际上有点儿故事会，套路都是：美国最近发生了一件有意思的事，在美国是怎么处理的，如果在中国会怎么样，然后总结升华一下。\n","permalink":"https://www.liuchang0812.com/posts/read/2023-11/","summary":"\u003cp\u003e最近主要读了《民主的细节》《芯片战争》和新出的《Elon Musk》几本书。《芯片战争》是在飞机上快速翻了一遍。《民主的细节》是因为前段时间《巨变第二天》特别火，国内还买不到，所以找了一下作者其它著作。《Elon Musk》则是在公司读书活动上白嫖的。\u003c/p\u003e","title":"2023 11 读书分享"},{"content":"这本书主要包含两个部分，第一个部分介绍了清代行政体系下几个主要角色的方方面面，包括职责、如何认命监管、怎么获取陋规，第二个部分介绍清朝司法税务等主要部门的运行机制。非常推荐。\n前半本书阅读下来，感想就是“百姓苦啊，只要和官府打交道就要被所有角色剥削”。统治阶级也知道这些陋规的存在，但是默认了这些行为，甚至将其中一些陋规合法化，不然无法维持整个行政体系。\n司法体系\n州县官只能使用民事案件以及不超过笞杖或枷号的轻微刑事案件。判决不需要上级批准但是需要定期上报。 如果有错判，州县官要遭受同样的罪责 治安与保甲制度，发动群众与连坐制。\n辖区内的民户组织成牌（十户）、甲（百户）和保（千户）等基本治安单位，并指定牌头、甲长、保正或保长。[1]州县官每年会向每户人家签发一个门牌，上面列出户主的姓名、年龄、职业和该户其他成员的姓名，包括亲戚和仆婢。[2]只要家中有人员进出变动，户主就要向甲长汇报。甲长有责任在保甲簿中予以登记，并修正门牌。[3]通常，保甲簿一式两份，一份由甲长保存，另一份由州县官保存。甲乙两簿定期交换：甲簿由甲长根据甲内实际人口的变动修正后，呈交给州县官，州县官就将乙簿交还给甲长由其作相应改动，如此循环。这种方式确保了保甲记录的不断更新。[4]\n保甲制度同时适用于乡村和州城县城，所有居民都包括在保甲组织内，包括无业者、流配人犯、娼妓和其他受法律制裁者。[5]保甲制的基本功能，是要建立起缉查违法，特别是缉查强盗、土匪的治安组织网络。[6]有些州县官还借保甲制以推进道德教化之功效。[7]保甲制度背后的深层理念是：每个人的行动都难以逃过邻里乡亲之耳目；若将邻里居民组织起来，官方掌握所有民户登记资料，则陌生人及违法者必定难以在守法居民中隐藏。\n尽管设立常平仓的目的是造福穷人，但实际上它并未给穷人带来福利。首先，由于粮仓设在州城县城，居住偏远的乡民常常享受不到好处。 尽管法律有禁令，[11]但儒户、衙役和粮行老板仍常常勾结书吏，假造名籍大量购买官米，从其低廉的价格中获利。[12]粮仓书吏和衙役常常对到官仓购米的百姓勒索钱财，或者要求他们超量返还从官仓借去的粮食。[13]为了将陈年粮食清仓，有的州县官常强迫百姓购买陈粮，即使他们并不需要。[14]百姓更有一种负担，即州县官常常以低于市场的价格向本州县百姓购粮，并要售粮者自己将粮食从乡村运送到官仓。[15]因此，朝廷曾发布一条规定：补充官仓的粮食必须从邻县购置；只有本县和邻近州县之间没有水运的情况下，州县官才可以在自己辖区内购粮。\n有时候政策是好的，执行起来却问题很多。\n根据曾任县官的方大湜的经验，灾害勘查的过程往往充满罪恶的勾当。如果将这一事务交由书吏、保甲长来办理，他们就会从事各种贪污活动。[41]如果委托给士绅，又容易出现徇私舞弊的情况。同时，州县官亲自到各家各户查访又极端困难。[42]王凤生认为最好的办法是由村长登记受灾人口，由士绅核查，再由专员作进一步审查。\n中国士绅的一个重要特点是：他们是唯一能合法地代表当地居民社群与官吏共商地方事务、参与治理过程的群体。这一特权从未扩展到其他任何社群和组织。\n具备进入特权阶层的条件，与特权身份实际获得，二者之间是有差距的。财富和田产本身，不是士绅身份的充分条件。庶民地主，不论拥有多少土地，也不属于士绅群体。“学绅”既不属于统治阶层，也不属于被统治阶层，他们属于一个中间阶级。[21]他们并未加入正式的政府，但却享有很高的威望、特权和统治阶级权力——这一事实将他们作为精英与普通大众区别开来。作为官僚集团的潜在候补成员，他们也可称作潜在的统治阶级。 官绅不在当地司法管辖权之下，也不受常规司法程序的约束。未经皇帝的允许，官员不得受审讯和判决。 只有财富与政治权力联结起来时，人们才能确保其自身和家庭的安宁。[21]这有助于解释为何人们渴望获得功名和当官。 作为一个特权阶层，他们渴望维持现状，抵制任何可能危害既定社会秩序的力量。地方防务，这样一种需要强有力的权威和财力支撑的任务，自然就落到了士绅肩上，因为他们为地方百姓所尊敬和追随并可以接触政府官员。 地方官吏既然不能跟士绅争辩附加费的合法性，又无力确立一个更高的折算率，就只好根据惯例按较低附加费率向士绅征税。为了弥补征税成本和衙门其他开支，官员只好将税收负担转嫁到不能据法抗争、无力保护自己的普通百姓头上。 顾炎武才认定，官绅、学绅、书吏、衙役这些豁免徭役的群体，正是引起百姓苦难的祸首。他认为，只有“废生员”才能缓解百姓的痛苦。 学而优则仕 ","permalink":"https://www.liuchang0812.com/posts/read/2023-07/","summary":"\u003cp\u003e这本书主要包含两个部分，第一个部分介绍了清代行政体系下几个主要角色的方方面面，包括职责、如何认命监管、怎么获取陋规，第二个部分介绍清朝司法税务等主要部门的运行机制。非常推荐。\u003c/p\u003e","title":"2023 07 读书分享：清代地方政府"},{"content":"强烈推荐，书的排版很好，翻译的也特别好。比较有意思的是前半部分，介绍了明代的世袭军户制度下，人们从想办法减少服役代价，到利用制度来进行套利的方法，以及制度对人们生活文化的影响。\n这本书是外国人写的，还有部分被删减的内容。有兴趣的可以看豆瓣上网友的整理。\n这本书介绍了群众面对制度时的几大策略：\n“优化处境”（strategies of optimization）：轮替、集中、补偿、代役（集中策略的延伸）。 “近水楼台”（strategies of proximity）：卫所军官和士兵利用自己在军事体制中的特殊地位参与非法贸易，浑水摸鱼。 “制度套利”（strategies of regulatory arbitrage）：被调入军屯的屯军擅长运用套利策略，借由军田与民田的差异渔利。 “诉诸先例”（strategies of precedent）：清初军户如何试图维护自己在明朝体制中享有的特权，或出于利益考量为旧体制招魂。（308-309） ","permalink":"https://www.liuchang0812.com/posts/read/2023-06-reading/","summary":"\u003cp\u003e强烈推荐，书的排版很好，翻译的也特别好。比较有意思的是前半部分，介绍了明代的世袭军户制度下，人们从想办法减少服役代价，到利用制度来进行套利的方法，以及制度对人们生活文化的影响。\u003c/p\u003e","title":"2023 06 读书分享：被统治的艺术"},{"content":"《城乡中国》豆瓣 4/5 分，一本关于中国土地财政的书，介绍了从建国以后关于土地的法律法规变化以及各方尝试。内容挺有意思，但是因为是文章合订本，内容有重复，逻辑性不太流畅。一些有意思的点： 关于自由迁徙：中国第一版的宪法是有写公民有自由迁徙的权力，在文化大革命的时候又被删了。教员在最开始的时候是不同意宪法中有自由迁徙的。 关于土地市场化：土地不许买卖 \u0026ndash;\u0026gt; 土地可以依法转让，但是要国务院立法。\u0026ndash;\u0026gt;国务院规定城市土地国有，可以流转。农村土地归集体，却一直不立法。\u0026ndash;\u0026gt; 各地实点实验：挂钩、地票等。 \u0026ndash;\u0026gt; 城市扩市或者征地。 只有国有土地可以流转。在超额土地利益面前，不再是人人平等。农民无法享受这一波红利。深圳是100%土地城市化国有化，也是第一个学习香港立法拍卖土地的。在宪法修改时，曾打算所有土地国有，为了减小影响，后面修改为“城市土地一律国有，农村土地归集体所有”。 作者认为解决问题的方法是：还权赋能，农地入市。但我认为这很难实现，土地财政已经绑架了太多人太多东西。如果最开始就农地入市也许我们可以像欧美一样人人住上大 house，但是历史没有假如。 《王氏之死》豆瓣 3/5 分，漫长的余生中推荐的一本书，但是读来实在没什么意思，内容也比较少。可能是我的能力问题，没有读到精髓。 ","permalink":"https://www.liuchang0812.com/posts/read/2023-05/","summary":"\u003ch2 id=\"城乡中国豆瓣httpsbookdoubancomsubject27015840\"\u003e《城乡中国》\u003ca href=\"https://book.douban.com/subject/27015840/\"\u003e豆瓣\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e4/5 分，一本关于中国土地财政的书，介绍了从建国以后关于土地的法律法规变化以及各方尝试。内容挺有意思，但是因为是文章合订本，内容有重复，逻辑性不太流畅。一些有意思的点：\u003c/li\u003e\n\u003cli\u003e关于自由迁徙：中国第一版的宪法是有写公民有自由迁徙的权力，在文化大革命的时候又被删了。教员在最开始的时候是不同意宪法中有自由迁徙的。\u003c/li\u003e\n\u003cli\u003e关于土地市场化：土地不许买卖 \u0026ndash;\u0026gt; 土地可以依法转让，但是要国务院立法。\u0026ndash;\u0026gt;国务院规定城市土地国有，可以流转。农村土地归集体，却一直不立法。\u0026ndash;\u0026gt; 各地实点实验：挂钩、地票等。 \u0026ndash;\u0026gt;  城市扩市或者征地。\u003c/li\u003e\n\u003cli\u003e只有国有土地可以流转。在超额土地利益面前，不再是人人平等。农民无法享受这一波红利。深圳是100%土地城市化国有化，也是第一个学习香港立法拍卖土地的。在宪法修改时，曾打算所有土地国有，为了减小影响，后面修改为“城市土地一律国有，农村土地归集体所有”。\u003c/li\u003e\n\u003cli\u003e作者认为解决问题的方法是：还权赋能，农地入市。但我认为这很难实现，土地财政已经绑架了太多人太多东西。如果最开始就农地入市也许我们可以像欧美一样人人住上大 house，但是历史没有假如。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"王氏之死豆瓣httpsbookdoubancomsubject6750187\"\u003e《王氏之死》\u003ca href=\"https://book.douban.com/subject/6750187/\"\u003e豆瓣\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e3/5 分，漫长的余生中推荐的一本书，但是读来实在没什么意思，内容也比较少。可能是我的能力问题，没有读到精髓。\u003c/li\u003e\n\u003c/ul\u003e","title":"2023 05 读书分享：城乡中国、王氏之死"},{"content":"漫长的余生 书名不好，书很不错。这种书名放在面前都可能不会被注意到。 作者希望用宫女王钟儿作为线索，介绍北魏的一段历史。但是实际读起来，感觉意义不大，不如直述。 之前对魏晋南北朝这段历史了解不多，读这本书还是比较吃力（人物名字太相似），但是北魏的历史还挺有意思。搜了一下国内有一部电视剧叫 胡笳汉月，可惜没有过审，被剪成了几集历史纪录片。 需要把主要人物的关系图整理一下，才能更好理解。 ^^子贵母死^^ 的制度真是残忍，本来是为了避免外戚乱权，却被几任皇太后利用来维持自己的地位。 %%{init: {'theme':'neutral'}}%% flowchart TD XiaoWD[孝文帝] FHH[冯皇后] CTH[常太后] WCD[文成帝] XianWD[献文帝] DFHH[大冯皇后] XFHH[小冯皇后] XWD[宣武帝] GZR[高照容] YX[元恂] subgraph 皇帝 WCD==长子==\u003eXianWD==长子==\u003eXiaoWD==次子==\u003eXWD XiaoWD==长子==\u003eYX end subgraph 皇后 CTH--选立--\u003eFHH FHH--侄女--\u003eDFHH FHH--侄女--\u003eXFHH DFHH--杀死--\u003eGZR end CTH--乳母--\u003eWCD FHH--乳母--\u003eXianWD FHH--杀死生母从小抚养--\u003eXiaoWD XiaoWD--皇后--\u003eDFHH XiaoWD--皇后--\u003eXFHH GZR--生母--\u003eXWD DFHH--抚养--\u003eXWD XFHH--抚养--\u003eYX 父母的语言 这本书的核心观点是小朋友3岁前接受到语言词汇对于智力发育有很大的影响。按照作者统计，经济差异大的家庭之间有3 kw的单词数差异。\n文章提到一个4T原则，还是很有道理的\nTune In 共情 Talk More 充分交流 Take Turns 交替交流 Turn off 关闭电子设备 书的逻辑性不太认可，表述也一般，可能和翻译有关，一般推荐\n","permalink":"https://www.liuchang0812.com/posts/read/2023-04/","summary":"\u003ch1 id=\"漫长的余生\"\u003e漫长的余生\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e书名不好，书很不错。这种书名放在面前都可能不会被注意到。\u003c/li\u003e\n\u003cli\u003e作者希望用宫女王钟儿作为线索，介绍北魏的一段历史。但是实际读起来，感觉意义不大，不如直述。\u003c/li\u003e\n\u003cli\u003e之前对魏晋南北朝这段历史了解不多，读这本书还是比较吃力（人物名字太相似），但是北魏的历史还挺有意思。搜了一下国内有一部电视剧叫 \u003ca href=\"http://www.baidu.com/link?url=akjxbWw6ixiptByKVDLG2VIBI_yUExzjgByrhypkvDc1HDzHfrUvnCVa_-IS9LxsXC2D4auS8y8hPGs2NxFNrgyfiqw1Rxtx6HaL9jhK9d1R6pnMtCqOm1RQ5WSLPqrU\"\u003e胡笳汉月\u003c/a\u003e，可惜没有过审，被剪成了几集历史纪录片。\u003c/li\u003e\n\u003cli\u003e需要把主要人物的关系图整理一下，才能更好理解。\u003c/li\u003e\n\u003cli\u003e^^子贵母死^^ 的制度真是残忍，本来是为了避免外戚乱权，却被几任皇太后利用来维持自己的地位。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"mermaid\"\u003e%%{init: {'theme':'neutral'}}%%\n\nflowchart TD\n    XiaoWD[孝文帝]\n    FHH[冯皇后]\n    CTH[常太后]\n    WCD[文成帝]\n    XianWD[献文帝]\n    DFHH[大冯皇后]\n    XFHH[小冯皇后]\n    XWD[宣武帝]\n    GZR[高照容]\n    YX[元恂]\n    subgraph 皇帝\n    WCD==长子==\u003eXianWD==长子==\u003eXiaoWD==次子==\u003eXWD\n     XiaoWD==长子==\u003eYX\n    end\n     \n    subgraph 皇后\n    CTH--选立--\u003eFHH\n  FHH--侄女--\u003eDFHH\n  FHH--侄女--\u003eXFHH\n   DFHH--杀死--\u003eGZR\n   end\n    CTH--乳母--\u003eWCD\n    FHH--乳母--\u003eXianWD\n    FHH--杀死生母从小抚养--\u003eXiaoWD\n    XiaoWD--皇后--\u003eDFHH\n    XiaoWD--皇后--\u003eXFHH\n    GZR--生母--\u003eXWD\n    DFHH--抚养--\u003eXWD\n    XFHH--抚养--\u003eYX\n\u003c/div\u003e\n\n\u003ch1 id=\"父母的语言\"\u003e父母的语言\u003c/h1\u003e\n\u003cp\u003e这本书的核心观点是小朋友3岁前接受到语言词汇对于智力发育有很大的影响。按照作者统计，经济差异大的家庭之间有3 kw的单词数差异。\u003c/p\u003e","title":"2023 04 读书分享：漫长的余生、父母的语言"},{"content":"小镇喧嚣：一个乡镇政治运作的演绎与阐释 推荐，华科大教授写的一本书，记录了在小镇调查的一年半期间遇到的事情，主要包括：镇政府如何处理上级检查，乡镇村干部如何收农业税，如何处理各种农村冲突上访等。\n文风不错，像读小说一样引人入胜。同时引用详细，可以学到大量不知道的知识。\n美丽新世界 一本反乌托邦世界的书，其中未来世界的设定很有意思。\n人类还通过基因工程被改造成几个等级，以便从事不同的工作。低等级的人类从事重复劳动，而他们因为智商低下，像动物一样被劳役而不会反抗。而高等级的人类，他们从小在睡眠中被催眠教育，不相信上帝，不相信爱情。人是通过试管培育的，没有父亲，没有母亲。“每个人都属于彼此。”所以男人可以和任何一个女性做爱，女性也可以和任何男性交往。他们没有嫉妒。没有排他的占有欲。A片高级到只要看的时候手扶把手，可以通过电磁波把感官感受直接作用于人体。而这些方式当然并不能消除人类所有的欲望而使人免于痛苦。当人有烦恼的时候，可以吃点“唆麻”，一种对人体无害的毒品。然后人就忘记烦恼，无忧无虑了。\n失去的三十年 介绍日本广场协定泡沫破裂相关历史和知识。这本书篇幅较小，内容也较少。看完之后留下的有印象的内容很少。后面有空再认真看一遍吧。\n","permalink":"https://www.liuchang0812.com/posts/read/2023-03-reading/","summary":"\u003ch1 id=\"小镇喧嚣一个乡镇政治运作的演绎与阐释\"\u003e小镇喧嚣：一个乡镇政治运作的演绎与阐释\u003c/h1\u003e\n\u003cp\u003e推荐，华科大教授写的一本书，记录了在小镇调查的一年半期间遇到的事情，主要包括：镇政府如何处理上级检查，乡镇村干部如何收农业税，如何处理各种农村冲突上访等。\u003c/p\u003e","title":"2023 03 读书分享"},{"content":" 最近在咸鱼上入了一个 kindle oasis，体验比之前的 kindle paperwhite 好太多了，最近买得最值的东西了。争取可以多看书多写文字分享，锻炼一下自己。\n《置身事内》介绍中国经济相关知识 个人觉的非常不错的书，值得 5 星推荐。之前在微信读书上看过，这几天又抽空在 kindle oasis 上看了一遍，还是收获很大。\n前段部分介绍了中国这几十年来经济发展过程与其中遇到的问题与改革方法，比较体系化的介绍了为什么从“财政包干”到“分税制”改革，再到“国税地税合并”和“房地产”。也介绍了中国政府的运作方式。也介绍了“京东方”和“光伏“产业发展的历史。 后段部分宏观分析了债务、工业化、国际贸易等，相对我就不太感兴趣了。\n作者文笔十分流畅，引用清晰，而且每章都推荐了很多相关的书。\n《永久记录》斯诺登传记 斯诺登自己写的传记，介绍了小时候的成长经历，在美国国安局的工作经历，以及后来在 HK 发生的事情。\n3 星推荐吧。作者的一些思考还有些意思。\n《他改变了中国》江泽民传记 4 星推荐。江主席的人生智慧。值的认真读一下，可以了解到很多历史细节。\n","permalink":"https://www.liuchang0812.com/posts/read/2023-02-reading/","summary":"\u003cblockquote\u003e\n\u003cp\u003e最近在咸鱼上入了一个 kindle oasis，体验比之前的 kindle paperwhite 好太多了，最近买得最值的东西了。争取可以多看书多写文字分享，锻炼一下自己。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1 id=\"置身事内介绍中国经济相关知识\"\u003e《置身事内》介绍中国经济相关知识\u003c/h1\u003e\n\u003cp\u003e个人觉的非常不错的书，值得 5 星推荐。之前在微信读书上看过，这几天又抽空在 kindle oasis 上看了一遍，还是收获很大。\u003c/p\u003e","title":"2023 02 读书分享"},{"content":"libco 协程，被分类到非对称协程。分类的方法是：\n对称协程（典型的如 golang 的 goroutine），一个协程 yield 后，执行机会不会直接返还到调用者，而是调度器来决定唤起哪个协程。 非对称协程（例如 libco ），一个协程 yield 后，会返还到调用者，继续执行调用者的函数。 非对称在于程序控制流转移到被调协程时使用的是 call/resume 操作，而当被调协程让出 CPU 时使用的却是 return/yield 操作。此外，协程间的地位也不对等，caller 与 callee 关系是确定的，不可更改的，非对称协程只能返回最初调用它的协程。\nhttps://zhuanlan.zhihu.com/p/51078499\n在 libco 的实现中，每个线程会有一个 stack 来维护当前的协程列表，调用 co_resume 则会压入一个协程，调用 co_yield 则会弹出一个协程（实际的实现是栈顶指针的加减）。\n所以，在实际使用过程中，如果涉及到复杂场景，需要用到 co_yield 来自己调度 libco 的协程。那么怎么来实现呢，有没有什么套路。我们可以参考这个自带例子来学习一下。\n因为需要自己调度协程，所以一般要把协程指针和对应任务信息封装到一个结构体中，同时使用一个 stack/queue 保存所有的协程（因为一个协程 yield 之后就找不到了，没办法自动继续执行）。\nstruct task_t // 一个任务结构体 { stCoRoutine_t *co; // 对应的协程指针 int fd; // 协程负责任务的参数 }; static stack\u0026lt;task_t*\u0026gt; g_readwrite; // 开一个全局变量来保存所有的任务 为了方便理解，可以先忽略例子中的多进程部分代码。代码先创建了若干个 readwrite_routine协程\nfor(int i=0;i\u0026lt;cnt;i++) { task_t * task = (task_t*)calloc( 1,sizeof(task_t) ); task-\u0026gt;fd = -1; // 特殊值 co_create( \u0026amp;(task-\u0026gt;co),NULL,readwrite_routine,task ); co_resume( task-\u0026gt;co ); // 压到 stack 中开始执行，跳转到下面的函数 } static void *readwrite_routine( void *arg ) { co_enable_hook_sys(); // hook read/write 等io调用走协程实现 task_t *co = (task_t*)arg; char buf[ 1024 * 16 ]; for(;;) { if( -1 == co-\u0026gt;fd ) // 第一次进来是 -1 特殊值，将 task 保存到 g_readwrite { g_readwrite.push( co ); co_yield_ct(); // 让出 cpu 到调用者，也就是主线程，继续创建协程。 } // 然后会进入到 accept_routine continue; int fd = co-\u0026gt;fd; // 从 accept_routine 切换回来，这个时候 fd 有值了 co-\u0026gt;fd = -1; // 标记为特殊值，下次循环会 yield 出去 for(;;) { // 任务逻辑 struct pollfd pf = { 0 }; pf.fd = fd; pf.events = (POLLIN|POLLERR|POLLHUP); co_poll( co_get_epoll_ct(),\u0026amp;pf,1,1000); int ret = read( fd,buf,sizeof(buf) ); if( ret \u0026gt; 0 ) { ret = write( fd,buf,ret ); } if( ret \u0026gt; 0 || ( -1 == ret \u0026amp;\u0026amp; EAGAIN == errno ) ) { continue; } close( fd ); break; } } return 0; } static void *accept_routine( void * ) { co_enable_hook_sys(); for(;;) { if( g_readwrite.empty() ) // g_readwrite 为空时，等待1s { struct pollfd pf = { 0 }; pf.fd = -1; poll( \u0026amp;pf,1,1000); continue; } struct sockaddr_in addr; //maybe sockaddr_un; memset( \u0026amp;addr,0,sizeof(addr) ); socklen_t len = sizeof(addr); int fd = co_accept(g_listen_fd, (struct sockaddr *)\u0026amp;addr, \u0026amp;len); if( fd \u0026lt; 0 ) { struct pollfd pf = { 0 }; pf.fd = g_listen_fd; pf.events = (POLLIN|POLLERR|POLLHUP); co_poll( co_get_epoll_ct(),\u0026amp;pf,1,1000 ); // co_accept/co_poll注册回调，在有数据的时候swap回来，然后让出 cpu，执行 co_eventloop continue; } if( g_readwrite.empty() ) // double check { close( fd ); continue; } SetNonBlock( fd ); task_t *co = g_readwrite.top(); // 取一个协程，分配这个 accept 的 fd co-\u0026gt;fd = fd; g_readwrite.pop(); co_resume( co-\u0026gt;co ); // 切换到改协程，继续执行 readwrite_routine } return 0; } 总结一下 使用 libco 自己调度协程的实现模式有：\n用一个全局队列保存所有的任务执行协程； 使用 task 结构体保存协程指针和任务参数； 任务执行协程初始化后压到协程队列，让出 cpu 给调用者； 任务分发协程在没有可用协程时（协程队列为空），等待任务协程空闲。有任务时，更新任务参数后唤醒执行协程。 ","permalink":"https://www.liuchang0812.com/posts/tech/os/libco-usage/","summary":"\u003cp\u003elibco 协程，被分类到非对称协程。分类的方法是：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e对称协程（典型的如 golang 的 goroutine），一个协程 yield 后，执行机会不会直接返还到调用者，而是调度器来决定唤起哪个协程。\u003c/li\u003e\n\u003cli\u003e非对称协程（例如 libco ），一个协程 yield 后，会返还到调用者，继续执行调用者的函数。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e非对称在于程序控制流转移到被调协程时使用的是 call/resume 操作，而当被调协程让出 CPU 时使用的却是 return/yield 操作。此外，协程间的地位也不对等，caller 与 callee 关系是确定的，不可更改的，非对称协程只能返回最初调用它的协程。\u003c/p\u003e","title":"libco usage"},{"content":"Paxos 协议与工程实现 写在前面，我没有完整实现过 Paxos 协议，不敢保证下面描述的内容完全正确。本文主要是学习的笔记，如果有错误，十分欢迎指出，大家一起讨论学习。\n本文所有内容都是参考 PaxosStore 论文 《PaxosStore: High-availability Storage Made Practical in WeChat》\n概念定义 为了后续方便描述，我们先定义会用到的概念\nProposal 提议，包含提议号和提议值； Prepare 第一阶段 Proposer 发出的请求，包含一个提议号； Promise 第一阶段 Proposer 回应的消息，包含一个提议号和一个（如果有）已经 Accepted 的最大提仪； Accept 第二阶段 Proposer 发出的请求，包含一个提议号和一个提议值； Accepted 第二阶段 Proposer 回应的消息，包含一个提议号。也表示一个提议被一个该 Proposer 接受； Chosen 代表一个提议被大多数的 Proposer 接受，不会再发生改变； Proposer 提议成员； Acceptor 发送 Accepted 消息的成员； Learner 学习者，不参与 Paxos 投票过程。 与可以用代码语言描述，参考 链接\n// Prepare 请求，包含一个提议号 struct Prepare { int n; }; // 在收到大多数的 Promised 请求后，发出的 Accept 请求，包含一个提仪号以及一个值。 // 这个值是 Promised 中最大提议号的值，如果所有 promised 都没有返回值，则可以自己提出任意值。 // 对应到工程实现上，则代表这个位置已经被占了，可以再起一轮新 paxos struct Accept { int n; void *value; }; // n 承诺不 accept 小于 n 的 accept 请求，返回当时最大提议号对应的值。 struct Promised { int n; Accept *proposal = nullptr; }; // 如果满足承诺，返回最大的提议号 struct Accepted { int n; }; // paxos 成员会在内存中纪录的值，包括最大的提议号，以及对应的值。 class Acceptor { int last_n = 0; Accept *proposal = nullptr; }; Basic Paxos 协议 Basic Paxos 是理论上的最基础的一致性算法，作用是：多个（奇数）成员确定唯一一个值。\n算法分为两轮，第一轮 Prepare 请求会得到承诺后续不通过小于本次 Prepare.n 的提议，同时返回自己已经 accepted 的最大提议。第二轮 Accept 请求会带上上一轮收到的最大提议值（如果没有，则可以自己提出），每个 Acceptor 在不违背承诺的情况下更新本地状态。\n一个提仪一旦被大多数结果 accepted，就会被认为是 chosen。对于一个值来说，accepted 还是可以变的，chosen 的永远不会变。一组经典的 paxos 实例只能确定（chosen）一个值。\n算法的详细描述可以参考论文：\nPhase 1.\nA proposer selects a proposal number n and sends a prepare request with number n to a majority of acceptors.\nIf an acceptor receives a prepare request with number n greater than that of any prepare request to which it has already responded, then it responds to the request with a promise not to accept any more proposals numbered less than n and with the highest-numbered proposal (if any) that it has accepted.\nPhase 2.\nIf the proposer receives a response to its prepare requests (numbered n) from a majority of acceptors, then it sends an accept request to each of those acceptors for a proposal numbered n with a value v, where v is the value of the highest-numbered proposal among the responses, or is any value if the responses reported no proposals.\nIf an acceptor receives an accept request for a proposal numbered n, it accepts the proposal unless it has already responded to a prepare request having a number greater than n.\n注意细节：\nAccept 请求中的 value 是一阶段返回所有 promised 中 n 最大的那个值。是 promised→proposal.n 的 n，而不是 promised.n acceptor 上 accept 值还是会被修改的。 在提议被大多数通过的一瞬间，这个值就确定下来了，再也不会被修改。 对于证明的思路是这么一种思路：证明一个值 chosen 不会被修改，可以通过加强的方式。如果一个大于当前提仪号并且值不同的提仪，不会被发出。chosen 的值自然就不会被修改。\nMulti Paxos 实现方法 可以看到，Basic Paxos 算法只能确定一个值，同时要走两轮流程。为了在真实系统上实际使用起来，还需要做一些修改优化。\n我们可以在 Basic Paxos 上增加一个 Entry ID 的维度，每个 Entry 保存一个值。同时，可以在第 i 个 Entry 中携带上第 i+1 个 Entry 的 Prepare 信息：当 $E_i$ 被 chosen 时，同时认为 $E_i+1$ 已经完成了 prepare 流程。\n工程实现上的问题 论文只描述了 Paxos 算法的流程和证明，在实际实现上，还有很多细节要处理，例如怎么 CatchUp、怎么 GetALL以及一些细节的问题。\n写读读问题 写读读的问题场景：假设三机日志都commit到了Entry 100，然后机器 A执行 Entry 101 的二轮过程然后挂掉。这个时候会读到 100 的值。然后机器 A 恢复同步状态到 BC，后续就读到了 Entry 101。\n重复执行问题 重复执行的问题场景：机器 A 收到一个写请求，在执行完 Paxos 后被 chosen，然后发送响应给客户端。这个响应可能因为网络原因未发到或者超时。然后客户端超时后重发请求到机器 B。机器 B 重新跑一次 Paxos 过程，然后回复客户端。这儿更新过程就会执行两次，如果是有状态的更新就会有问题。\n所以要让请求幂等，方法就是在请求上带上 request ID， svr 端检查 request ID 。\nThe request ID is generated by the client and sent together with the write request, and checked by the PaxosStore node to detect potential duplication of actual request handling.\nPlogKV 实现问题 文章同时提到了一个 PaxosLog for KV Data，可以优化掉 DB 部分的成本。那么正常的plog存储的key应该是entityid和entryid？怎么用key来查询？\n答案是只维护两个entry，一个最新chosen，一个pending。每个 key 都是一个 paxos 实例。\n参考 https://sf-zhou.github.io/paxos/paxos_store_03_consensus.html http://www.vldb.org/pvldb/vol10/p1730-lin.pdf ","permalink":"https://www.liuchang0812.com/posts/tech/os/paxos-note/","summary":"\u003ch1 id=\"paxos-协议与工程实现\"\u003ePaxos 协议与工程实现\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e写在前面，我没有完整实现过 Paxos 协议，不敢保证下面描述的内容完全正确。本文主要是学习的笔记，如果有错误，十分欢迎指出，大家一起讨论学习。\u003c/p\u003e","title":"Paxos Algorithm Note"},{"content":"cgroup 全称是 control group，是 linux 下的一个内核模块，用来控制进程的系统资源使用。例如可以限制进程 cpu 使用量、内存使用量等。比如知名开源软件 docker 就是基于 cgroup 来限制容器资源使用，使用 namespace 隔离进程空间。\ncgroup 分为 v1 和 v2 两个版本。常用的子系统有：\ncpu/cpuset/cpuacct：限制和统计 cpu 的用量 memory：限制内存的用量 blkio：限制块设备的用量，但是只能限制 direct io 使用方式 cgroup 基于 linux vfs 技术，将 cgroup 映射到一个目录。系统管理员通过在目录下创建文件的方式来使用 cgroup。默认情况下，cgroup 映射的目录为 /sys/fs/cgroup ，该目录下每个目录对应一个子系统。系统管理员可以在子系统目录中新建树状目录来设置 cgroup 限制，例如 /sys/fs/cgroup/cpu/g1 代表一类进程限制。\n➜ ~ ls /sys/fs/cgroup blkio cpu cpuacct cpu,cpuacct cpuset devices freezer hugetlb memory net_cls oom perf_event pids systemd 除了使用 /sys/fs/cgroup ，还可以通过 cgcreate 、 cgexec 等命令来使用 cgroup。例如\n# 使用 /sys/fs/cgroup/cpu/test_cpu 来限制 ./test 进程运行 cgexec -g cpu:test_cpu ./test ","permalink":"https://www.liuchang0812.com/posts/tech/os/cgroup/","summary":"\u003cp\u003ecgroup 全称是 control group，是 linux 下的一个内核模块，用来控制进程的系统资源使用。例如可以限制进程 cpu 使用量、内存使用量等。比如知名开源软件 docker 就是基于 cgroup 来限制容器资源使用，使用 namespace 隔离进程空间。\u003c/p\u003e","title":"cgroup usage"},{"content":" 我们以 C++11 的 API 接口定义来描述\n大家在编写多线程类的程序时，会用到信号量 condition_variable，有没有疑惑过为什么 cv 这类接口，在调用 wait/notify 时候还需要用一个 mutex。\n为什么 cv.wait() 需要用 mutex 保护？ 常见的 cv 代码实现类似下方，包含三个部分：检查条件是否满足；如果不满足等待到满足；等待到满足后执行逻辑。\nstd::unique_lock\u0026lt;std::mutex\u0026gt; lock(cv_m); while (!cond_ok()) { // 1. 检查条件是否满足 wait(lock); // 2. 等待信号 } // do somethings with cond // 3. 执行逻辑 如果没有一个锁保护这三个部分，会出现两种情况：\n在第一部分检查条件不满足，准备进行第二部分 wait信号时，另一个线程达到了信号条件并 signal ，然后执行到 wait 。这个时候 wiat 就永远挂在这儿了。 在第二部分执行完成后，认为已经达到条件，准备执行第三部分的业务逻辑。另一个线程修改了条件。第三部分执行的假设是条件已经满足，违反了假设，业务逻辑可能会有问题。 所以一般会通过一个 mutex 将上述三个部分看起一个原子操作，将检查条件是否完成与等待信号量同时执行。其它线程如果 signal 信号，一定是在检查条件之前或者wait之后。\n附录 lock-and-condition-variable cppreference ","permalink":"https://www.liuchang0812.com/posts/tech/os/why-conv-need-a-mutex/","summary":"\u003cblockquote\u003e\n\u003cp\u003e我们以 \u003ccode\u003eC++11\u003c/code\u003e 的 API 接口定义来描述\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e大家在编写多线程类的程序时，会用到信号量 \u003ca href=\"https://en.cppreference.com/w/cpp/thread/condition_variable\"\u003econdition_variable\u003c/a\u003e，有没有疑惑过为什么 cv 这类接口，在调用 \u003ccode\u003ewait/notify\u003c/code\u003e 时候还需要用一个 \u003ccode\u003emutex\u003c/code\u003e。\u003c/p\u003e\n\u003ch2 id=\"为什么--cvwait-需要用-mutex-保护\"\u003e为什么  \u003ccode\u003ecv.wait()\u003c/code\u003e 需要用 \u003ccode\u003emutex\u003c/code\u003e 保护？\u003c/h2\u003e\n\u003cp\u003e常见的 \u003ccode\u003ecv\u003c/code\u003e 代码实现类似下方，包含三个部分：检查条件是否满足；如果不满足等待到满足；等待到满足后执行逻辑。\u003c/p\u003e","title":"Why Does Conv Need a Mutex"},{"content":"书名：1984 政治小说，推荐指数 4 颗星\n小说虚构了一个极权社会，介绍了为真理部工作的外党成员温斯顿的故事。在极权社会下，到处都有电屏的监视。人们每天还要进行仇恨会的活动。对于不认同老大哥统治的思想有“问题”的人，会被思想警察完全从社会上抹去。\n主人公为真理部工作，工作内容是篡改历史，抹去被消失人的纪录。小说中主要分为两部分：一部分是认识女主，和女主发生的故事。另一部分则是被思想警察钓鱼执法，被惨烈的思想改造。\n书名：大逃港 政治向的报告文学，推荐指数 4 颗星\n这本书主要介绍了在建国后深圳人民群众逃港的故事。稍微的有点儿故事会写法。人民不管姓资还是姓社，只关心能不能吃饱肚子过上好日子，于是用脚投票，冒着生命危险去逃港。在改革开放后，则大量减少了逃港行为。\n书名：风格的要素 关于英语写作的小册子，推荐指数 2 颗星\n","permalink":"https://www.liuchang0812.com/posts/read/2022-05-reading/","summary":"\u003ch1 id=\"书名1984\"\u003e书名：1984\u003c/h1\u003e\n\u003cp\u003e政治小说，推荐指数 4 颗星\u003c/p\u003e\n\u003cp\u003e小说虚构了一个极权社会，介绍了为真理部工作的外党成员温斯顿的故事。在极权社会下，到处都有电屏的监视。人们每天还要进行仇恨会的活动。对于不认同老大哥统治的思想有“问题”的人，会被思想警察完全从社会上抹去。\u003c/p\u003e","title":"2022 05 读书分享"},{"content":"记忆化搜索，刚好卡过去\n执行用时：1964 ms, 在所有 C++ 提交中击败了 5.08% 的用户\nint mem[100][100][100][100]; class Solution { public: // 0 unknow // 1 true // 2 false bool dfs(const vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; grid, int x1, int y1, int x2, int y2) { if (x1 \u0026gt;= grid.size() || x2 \u0026gt;= grid.size() || y1\u0026gt;=grid[0].size() || y2 \u0026lt; 0 || x2 \u0026lt; 0 || x1 \u0026gt; x2 || y1 \u0026gt; y2) return false; if ((x2 - x1 + y2 - y1)%2==0) return false; if (mem[x1][y1][x2][y2] != 0) { return mem[x1][y1][x2][y2] == 1; } if ( x2 - x1 + y2 - y1 == 1 \u0026amp;\u0026amp; grid[x1][y1] == \u0026#39;(\u0026#39; \u0026amp;\u0026amp; grid[x2][y2] == \u0026#39;)\u0026#39;) { mem[x1][y1][x2][y2] = 1; return true; } if (grid[x1][y1] == \u0026#39;(\u0026#39; \u0026amp;\u0026amp; grid[x2][y2] == \u0026#39;)\u0026#39;){ bool tmp = dfs(grid, x1+1, y1, x2-1, y2) || dfs(grid, x1+1, y1, x2, y2-1) || dfs(grid, x1, y1+1, x2-1, y2) || dfs(grid, x1, y1+1, x2, y2-1); if (tmp) { mem[x1][y1][x2][y2] = 1; return true; } for (int i=x1; i\u0026lt;=x2; ++i) for (int j=y1; j\u0026lt;=y2; ++j) { if (i == x1 \u0026amp;\u0026amp; j==y1) continue; if (i == x2 \u0026amp;\u0026amp; j==y2) continue; if ((dfs(grid, x1, y1, i, j) \u0026amp;\u0026amp; dfs(grid, i, j+1, x2, y2))) { mem[x1][y1][x2][y2] = 1; return true; } if (dfs(grid, x1, y1, i, j) \u0026amp;\u0026amp; dfs(grid, i+1, j, x2, y2)) { mem[x1][y1][x2][y2] = 1; return true; } } mem[x1][y1][x2][y2] = 2; return false; } else { mem[x1][y1][x2][y2] = 2; return false; } } bool hasValidPath(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; grid) { int row = grid.size(); int col = grid[0].size(); if ((row + col)%2==0) return false; if ( grid[0][0] == \u0026#39;)\u0026#39; || grid[row - 1][col - 1] == \u0026#39;(\u0026#39;) return false; memset(mem, 0, sizeof mem); return dfs(grid, 0, 0, row-1, col -1); } }; 题解里面有一个写法很好，可以学习一下\nclass Solution { public: bool hasValidPath(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; \u0026amp;grid) { int m = grid.size(), n = grid[0].size(); if ((m + n) % 2 == 0 || grid[0][0] == \u0026#39;)\u0026#39; || grid[m - 1][n - 1] == \u0026#39;(\u0026#39;) return false; // 剪枝 bool vis[m][n][(m + n + 1) / 2]; memset(vis, 0, sizeof(vis)); function\u0026lt;bool(int, int, int)\u0026gt; dfs = [\u0026amp;](int x, int y, int c) -\u0026gt; bool { if (c \u0026gt; m - x + n - y - 1) return false; // 剪枝：即使后面都是 \u0026#39;)\u0026#39; 也不能将 c 减为 0 if (x == m - 1 \u0026amp;\u0026amp; y == n - 1) return c == 1; // 终点一定是 \u0026#39;)\u0026#39; if (vis[x][y][c]) return false; // 重复访问 vis[x][y][c] = true; c += grid[x][y] == \u0026#39;(\u0026#39; ? 1 : -1; return c \u0026gt;= 0 \u0026amp;\u0026amp; (x \u0026lt; m - 1 \u0026amp;\u0026amp; dfs(x + 1, y, c) || y \u0026lt; n - 1 \u0026amp;\u0026amp; dfs(x, y + 1, c)); // 往下或者往右 }; return dfs(0, 0, 0); } }; ","permalink":"https://www.liuchang0812.com/posts/tech/leetcode/2267/","summary":"\u003cp\u003e记忆化搜索，刚好卡过去\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e执行用时：1964 ms, 在所有 C++ 提交中击败了 5.08% 的用户\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003eint\u003c/span\u003e mem[\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e][\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e][\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e][\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eclass\u003c/span\u003e Solution {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003epublic\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#007f7f\"\u003e// 0 unknow\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e\u003c/span\u003e    \u003cspan style=\"color:#007f7f\"\u003e// 1 true\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e\u003c/span\u003e    \u003cspan style=\"color:#007f7f\"\u003e// 2 false\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e\u003c/span\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003ebool\u003c/span\u003e dfs(\u003cspan style=\"color:#fff;font-weight:bold\"\u003econst\u003c/span\u003e vector\u0026lt;vector\u0026lt;\u003cspan style=\"color:#fff;font-weight:bold\"\u003echar\u003c/span\u003e\u0026gt;\u0026gt;\u0026amp; grid, \u003cspan style=\"color:#fff;font-weight:bold\"\u003eint\u003c/span\u003e x1, \u003cspan style=\"color:#fff;font-weight:bold\"\u003eint\u003c/span\u003e y1, \u003cspan style=\"color:#fff;font-weight:bold\"\u003eint\u003c/span\u003e x2, \u003cspan style=\"color:#fff;font-weight:bold\"\u003eint\u003c/span\u003e y2) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#fff;font-weight:bold\"\u003eif\u003c/span\u003e (x1 \u0026gt;= grid.size() || x2 \u0026gt;= grid.size() || y1\u0026gt;=grid[\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e].size() || y2 \u0026lt; \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e || x2 \u0026lt; \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e || x1 \u0026gt; x2 || y1 \u0026gt; y2) \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#fff;font-weight:bold\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#fff;font-weight:bold\"\u003efalse\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#fff;font-weight:bold\"\u003eif\u003c/span\u003e ((x2 - x1 + y2 - y1)%\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e==\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e) \u003cspan style=\"color:#fff;font-weight:bold\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#fff;font-weight:bold\"\u003efalse\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#fff;font-weight:bold\"\u003eif\u003c/span\u003e (mem[x1][y1][x2][y2] != \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#fff;font-weight:bold\"\u003ereturn\u003c/span\u003e mem[x1][y1][x2][y2] == \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#fff;font-weight:bold\"\u003eif\u003c/span\u003e ( x2 - x1 + y2 - y1 == \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e \u0026amp;\u0026amp; grid[x1][y1] == \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;(\u0026#39;\u003c/span\u003e \u0026amp;\u0026amp; grid[x2][y2] == \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;)\u0026#39;\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            mem[x1][y1][x2][y2] = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#fff;font-weight:bold\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#fff;font-weight:bold\"\u003etrue\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#fff;font-weight:bold\"\u003eif\u003c/span\u003e (grid[x1][y1] == \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;(\u0026#39;\u003c/span\u003e \u0026amp;\u0026amp; grid[x2][y2] == \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;)\u0026#39;\u003c/span\u003e){\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#fff;font-weight:bold\"\u003ebool\u003c/span\u003e tmp = dfs(grid, x1+\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, y1, x2-\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, y2) ||\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        dfs(grid, x1+\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, y1, x2, y2-\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e) ||\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        dfs(grid, x1, y1+\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, x2-\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, y2) ||\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        dfs(grid, x1, y1+\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, x2, y2-\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#fff;font-weight:bold\"\u003eif\u003c/span\u003e (tmp) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            mem[x1][y1][x2][y2] = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#fff;font-weight:bold\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#fff;font-weight:bold\"\u003etrue\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#fff;font-weight:bold\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#fff;font-weight:bold\"\u003eint\u003c/span\u003e i=x1; i\u0026lt;=x2; ++i) \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#fff;font-weight:bold\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#fff;font-weight:bold\"\u003eint\u003c/span\u003e j=y1; j\u0026lt;=y2; ++j) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#fff;font-weight:bold\"\u003eif\u003c/span\u003e (i == x1 \u0026amp;\u0026amp; j==y1) \u003cspan style=\"color:#fff;font-weight:bold\"\u003econtinue\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#fff;font-weight:bold\"\u003eif\u003c/span\u003e (i == x2 \u0026amp;\u0026amp; j==y2) \u003cspan style=\"color:#fff;font-weight:bold\"\u003econtinue\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#fff;font-weight:bold\"\u003eif\u003c/span\u003e ((dfs(grid, x1, y1, i, j) \u0026amp;\u0026amp; dfs(grid, i, j+\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, x2, y2))) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    mem[x1][y1][x2][y2] = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    \u003cspan style=\"color:#fff;font-weight:bold\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#fff;font-weight:bold\"\u003etrue\u003c/span\u003e; \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#fff;font-weight:bold\"\u003eif\u003c/span\u003e (dfs(grid, x1, y1, i, j) \u0026amp;\u0026amp; dfs(grid, i+\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, j, x2, y2)) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    mem[x1][y1][x2][y2] = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    \u003cspan style=\"color:#fff;font-weight:bold\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#fff;font-weight:bold\"\u003etrue\u003c/span\u003e; \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        mem[x1][y1][x2][y2] = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#fff;font-weight:bold\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#fff;font-weight:bold\"\u003efalse\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#fff;font-weight:bold\"\u003eelse\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    mem[x1][y1][x2][y2] = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#fff;font-weight:bold\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#fff;font-weight:bold\"\u003efalse\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003ebool\u003c/span\u003e hasValidPath(vector\u0026lt;vector\u0026lt;\u003cspan style=\"color:#fff;font-weight:bold\"\u003echar\u003c/span\u003e\u0026gt;\u0026gt;\u0026amp; grid) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#fff;font-weight:bold\"\u003eint\u003c/span\u003e row = grid.size();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#fff;font-weight:bold\"\u003eint\u003c/span\u003e col = grid[\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e].size();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#fff;font-weight:bold\"\u003eif\u003c/span\u003e ((row + col)%\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e==\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e) \u003cspan style=\"color:#fff;font-weight:bold\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#fff;font-weight:bold\"\u003efalse\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#fff;font-weight:bold\"\u003eif\u003c/span\u003e ( grid[\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e][\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e] == \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;)\u0026#39;\u003c/span\u003e || grid[row - \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e][col - \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e] == \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;(\u0026#39;\u003c/span\u003e) \u003cspan style=\"color:#fff;font-weight:bold\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#fff;font-weight:bold\"\u003efalse\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        memset(mem, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e, \u003cspan style=\"color:#fff;font-weight:bold\"\u003esizeof\u003c/span\u003e mem);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#fff;font-weight:bold\"\u003ereturn\u003c/span\u003e dfs(grid, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e, row-\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, col -\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e题解里面有一个写法很好，可以学习一下\u003c/p\u003e","title":"2267. 检查是否有合法括号字符串路径"},{"content":"爬楼梯的加强版本，分别提前生成三个字母和四个字母的 fib 数组，然后分组统计后相乘。代码如下：\nclass Solution { public: int countTexts(string pressedKeys) { int f1[100005]; int f2[100005]; memset(f1, 0, sizeof f1); memset(f2, 0, sizeof f2); f1[0] = 1; f1[1] = 2; f1[2] = 4; f2[0] = 1; f2[1] = 2; f2[2] = 4; f2[3] = 8; for (int i=3; i\u0026lt;100005; ++i) f1[i] = (0LL + f1[i-1] + f1[i-2] + f1[i-3])%int(1e9+7); for (int i=4; i\u0026lt;100005; ++i) f2[i] = (0LL + f2[i-1] + f2[i-2] + f2[i-3] + f2[i-4])%int(1e9+7); int ans = 1; int cur_ch = pressedKeys[0]; int cur_cnt = 1; for (int i=1; i\u0026lt;pressedKeys.size(); ++i) { if (pressedKeys[i] != cur_ch) { if (cur_ch == \u0026#39;7\u0026#39; || cur_ch == \u0026#39;9\u0026#39;) ans = 1LL *ans * f2[cur_cnt - 1] % int(1e9+7); else ans = 1LL *ans * f1[cur_cnt - 1] % int(1e9+7); cur_ch = pressedKeys[i]; cur_cnt = 1; } else { ++ cur_cnt; } } if (cur_ch == \u0026#39;7\u0026#39; || cur_ch == \u0026#39;9\u0026#39;) ans = 1LL * ans * f2[cur_cnt - 1] % int(1e9+7); else ans = 1LL * ans * f1[cur_cnt - 1] % int(1e9+7); return ans; } }; ","permalink":"https://www.liuchang0812.com/posts/tech/leetcode/leetcode2266/","summary":"\u003cp\u003e爬楼梯的加强版本，分别提前生成三个字母和四个字母的 fib 数组，然后分组统计后相乘。代码如下：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eclass\u003c/span\u003e Solution {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003epublic\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003eint\u003c/span\u003e countTexts(string pressedKeys) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#fff;font-weight:bold\"\u003eint\u003c/span\u003e f1[\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100005\u003c/span\u003e];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#fff;font-weight:bold\"\u003eint\u003c/span\u003e f2[\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100005\u003c/span\u003e];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        memset(f1, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e, \u003cspan style=\"color:#fff;font-weight:bold\"\u003esizeof\u003c/span\u003e f1);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        memset(f2, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e, \u003cspan style=\"color:#fff;font-weight:bold\"\u003esizeof\u003c/span\u003e f2);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        f1[\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e] = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e; f1[\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e] = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e; f1[\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e] = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e; \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        f2[\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e] = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e; f2[\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e] = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e; f2[\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e] = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e; f2[\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e] = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e8\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#fff;font-weight:bold\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#fff;font-weight:bold\"\u003eint\u003c/span\u003e i=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e; i\u0026lt;\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100005\u003c/span\u003e; ++i) f1[i] = (\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0LL\u003c/span\u003e + f1[i-\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e] + f1[i-\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e] + f1[i-\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e])%\u003cspan style=\"color:#fff;font-weight:bold\"\u003eint\u003c/span\u003e(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1e9\u003c/span\u003e+\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e7\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#fff;font-weight:bold\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#fff;font-weight:bold\"\u003eint\u003c/span\u003e i=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e; i\u0026lt;\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100005\u003c/span\u003e; ++i) f2[i] = (\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0LL\u003c/span\u003e + f2[i-\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e] + f2[i-\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e] + f2[i-\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e] + f2[i-\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e])%\u003cspan style=\"color:#fff;font-weight:bold\"\u003eint\u003c/span\u003e(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1e9\u003c/span\u003e+\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e7\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#fff;font-weight:bold\"\u003eint\u003c/span\u003e ans = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#fff;font-weight:bold\"\u003eint\u003c/span\u003e cur_ch = pressedKeys[\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#fff;font-weight:bold\"\u003eint\u003c/span\u003e cur_cnt = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#fff;font-weight:bold\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#fff;font-weight:bold\"\u003eint\u003c/span\u003e i=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e; i\u0026lt;pressedKeys.size(); ++i) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#fff;font-weight:bold\"\u003eif\u003c/span\u003e (pressedKeys[i] != cur_ch) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#fff;font-weight:bold\"\u003eif\u003c/span\u003e (cur_ch == \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;7\u0026#39;\u003c/span\u003e || cur_ch == \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;9\u0026#39;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    ans = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1LL\u003c/span\u003e *ans * f2[cur_cnt - \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e] % \u003cspan style=\"color:#fff;font-weight:bold\"\u003eint\u003c/span\u003e(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1e9\u003c/span\u003e+\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e7\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#fff;font-weight:bold\"\u003eelse\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    ans = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1LL\u003c/span\u003e *ans *  f1[cur_cnt - \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e] % \u003cspan style=\"color:#fff;font-weight:bold\"\u003eint\u003c/span\u003e(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1e9\u003c/span\u003e+\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e7\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                cur_ch = pressedKeys[i];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                cur_cnt = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            } \u003cspan style=\"color:#fff;font-weight:bold\"\u003eelse\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                ++ cur_cnt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#fff;font-weight:bold\"\u003eif\u003c/span\u003e (cur_ch == \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;7\u0026#39;\u003c/span\u003e || cur_ch == \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;9\u0026#39;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            ans = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1LL\u003c/span\u003e * ans * f2[cur_cnt - \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e] % \u003cspan style=\"color:#fff;font-weight:bold\"\u003eint\u003c/span\u003e(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1e9\u003c/span\u003e+\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e7\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#fff;font-weight:bold\"\u003eelse\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            ans = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1LL\u003c/span\u003e * ans * f1[cur_cnt - \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e] % \u003cspan style=\"color:#fff;font-weight:bold\"\u003eint\u003c/span\u003e(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1e9\u003c/span\u003e+\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e7\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#fff;font-weight:bold\"\u003ereturn\u003c/span\u003e ans;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"2266. 统计打字方案数"},{"content":"尘劫: 知青畅想曲 一本名字和封面看起来都非常像地摊文学的书，实际上却是“中共党史出版社”出版的关于知青的报告文学，内容包含了大量真实的知青故事，读来让人不禁唏嘘。\n一个人的命运在历史的长河里太过于脆弱。\n里面最触动的一段是：知青为了保留回城的资格，会同居而不结婚，生的孩子没有办法上户口。在允许回城后，只能将孩子托付给当地人。\n","permalink":"https://www.liuchang0812.com/posts/read/2022-04-reading/","summary":"\u003ch1 id=\"尘劫知青畅想曲\"\u003e尘劫: 知青畅想曲\u003c/h1\u003e\n\u003cp\u003e一本名字和封面看起来都非常像地摊文学的书，实际上却是“中共党史出版社”出版的关于知青的报告文学，内容包含了大量真实的知青故事，读来让人不禁唏嘘。\u003c/p\u003e","title":"2022 04 读书分享"},{"content":"Golang error 是一个包含了 Error() string 函数的接口，任何实现了 Error() string 的结构体都可以认为是 error 类型。\n// The error built-in interface type is the conventional interface for // representing an error condition, with the nil value representing no error. type error interface { Error() string } 对于简单场景，返回一个带字符串描述的 error 可以通过 return errors.New(\u0026quot;this is a err\u0026quot;) 来实现。其内部实现的机制为：定义了一个 errorString 的结构体，调用 Error() 的时候返回初始化时传入的字符串。\n// New returns an error that formats as the given text. // Each call to New returns a distinct error value even if the text is identical. func New(text string) error { return \u0026amp;errorString{text} } // errorString is a trivial implementation of error. type errorString struct { s string } func (e *errorString) Error() string { return e.s } 对于稍微复杂的场景，如果希望返回的错误信息中包含格式化字符串，可以通过 fmt.Errorf 来实现。其内部的实现为：通过一个 Printer 生成字符串，对于不包含异常的情况，调用上述的 errors.New。否则，返回一个 wrapError 结构体，保存包含的子 error ，并可以通过 Unwrap 取出。\nfunc Errorf(format string, a ...any) error { p := newPrinter() p.wrapErrs = true p.doPrintf(format, a) s := string(p.buf) var err error if p.wrappedErr == nil { err = errors.New(s) } else { err = \u0026amp;wrapError{s, p.wrappedErr} } p.free() return err } type wrapError struct { msg string err error } func (e *wrapError) Error() string { return e.msg } func (e *wrapError) Unwrap() error { return e.err } https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully ","permalink":"https://www.liuchang0812.com/posts/tech/golang/error-impl/","summary":"\u003cp\u003eGolang \u003ccode\u003eerror\u003c/code\u003e 是一个包含了 \u003ccode\u003eError() string\u003c/code\u003e 函数的接口，任何实现了 \u003ccode\u003eError() string\u003c/code\u003e 的结构体都可以认为是 \u003ccode\u003eerror\u003c/code\u003e 类型。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e// The error built-in interface type is the conventional interface for\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e// representing an error condition, with the nil value representing no error.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e\u003c/span\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003etype\u003c/span\u003e \u003cspan style=\"color:#fff;font-weight:bold\"\u003eerror\u003c/span\u003e \u003cspan style=\"color:#fff;font-weight:bold\"\u003einterface\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tError() \u003cspan style=\"color:#fff;font-weight:bold\"\u003estring\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e对于简单场景，返回一个带字符串描述的 \u003ccode\u003eerror\u003c/code\u003e 可以通过 \u003ccode\u003ereturn errors.New(\u0026quot;this is a err\u0026quot;)\u003c/code\u003e 来实现。其内部\u003ca href=\"https://go.dev/src/errors/errors.go#L58\"\u003e实现\u003c/a\u003e的机制为：定义了一个 \u003ccode\u003eerrorString\u003c/code\u003e 的结构体，调用 \u003ccode\u003eError()\u003c/code\u003e 的时候返回初始化时传入的字符串。\u003c/p\u003e","title":"golang | error 的内部实现"},{"content":"[]byte 和 string 有什么区别？类型转换需要拷贝数据吗？如何选择正确的类型？\n[]byte和string的类型字义非常类似，[]byte 比 string 多一个 cap 成员。string 在大多数的语言中都表示不可变字符串，[]byte 则是可以修改的数组分片。所以在做 []byte 和 string 转换的时候，如果只是简单的将指针复制，就相当于同一块内存同时有了可变和不可变引用，修改了 []byte 会影响到 string 的不可变性（rust 选手应该比较熟悉）。所以做类型转换时，会额外的有内存申请与数据拷贝动作。\n至于在编码的时候该选择哪个类型，可以参考 andybalholm 的回答：尽量使用 string ，除非要频繁修改字符串或者要与使用的接口保持一致。\nMy advice would be to use string by default when you're working with text. But use []byte instead if one of the following conditions applies: - The mutability of a []byte will significantly reduce the number of allocations needed. - You are dealing with an API that uses []byte, and avoiding a conversion to string will simplify your code. type slice struct { data uintptr len int cap int } type string struct { data uintptr len int } // ByteSliceFromString returns a NUL-terminated slice of bytes // containing the text of s. If s contains a NUL byte at any // location, it returns (nil, syscall.EINVAL). func ByteSliceFromString(s string) ([]byte, error) { if strings.IndexByte(s, 0) != -1 { return nil, syscall.EINVAL } a := make([]byte, len(s)+1) copy(a, s) return a, nil } refs https://syslog.ravelin.com/byte-vs-string-in-go-d645b67ca7ff\nhttps://cs.opensource.google/go/go/+/master:src/cmd/vendor/golang.org/x/sys/windows/syscall.go;l=40?q=slicetostring\u0026amp;ss=go%2Fgo\nhttps://stackoverflow.com/questions/10826651/when-to-use-byte-or-string-in-go\n","permalink":"https://www.liuchang0812.com/posts/tech/golang/byte-slice-vs-string/","summary":"\u003cp\u003e[]byte 和 string 有什么区别？类型转换需要拷贝数据吗？如何选择正确的类型？\u003c/p\u003e\n\u003cp\u003e[]byte和string的类型字义非常类似，[]byte 比 string 多一个 cap 成员。string 在大多数的语言中都表示不可变字符串，[]byte 则是可以修改的数组分片。所以在做 []byte 和 string 转换的时候，如果只是简单的将指针复制，就相当于同一块内存同时有了可变和不可变引用，修改了 []byte 会影响到 string 的不可变性（rust 选手应该比较熟悉）。所以做类型转换时，会额外的有内存申请与数据拷贝动作。\u003c/p\u003e","title":"golang | []byte 和 string 的区别与适用场景"}]