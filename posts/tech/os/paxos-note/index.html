<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Paxos Algorithm Note | ​Tech and Text Tales</title>
<meta name=keywords content="algorithm,paxos"><meta name=description content="学习 PaxosStore 中的 Paxos 实现。"><meta name=author content="Chang Liu"><link rel=canonical href=https://www.liuchang0812.com/posts/tech/os/paxos-note/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://www.liuchang0812.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.liuchang0812.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.liuchang0812.com/favicon-32x32.png><link rel=apple-touch-icon href=https://www.liuchang0812.com/apple-touch-icon.png><link rel=mask-icon href=https://www.liuchang0812.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://www.liuchang0812.com/posts/tech/os/paxos-note/><link rel=stylesheet href=/gitalk.css><script src=/gitalk.min.js></script><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Paxos Algorithm Note"><meta property="og:description" content="学习 PaxosStore 中的 Paxos 实现。"><meta property="og:type" content="article"><meta property="og:url" content="https://www.liuchang0812.com/posts/tech/os/paxos-note/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-06-26T20:02:45+08:00"><meta property="article:modified_time" content="2022-06-26T20:02:45+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Paxos Algorithm Note"><meta name=twitter:description content="学习 PaxosStore 中的 Paxos 实现。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.liuchang0812.com/posts/"},{"@type":"ListItem","position":2,"name":"Paxos Algorithm Note","item":"https://www.liuchang0812.com/posts/tech/os/paxos-note/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Paxos Algorithm Note","name":"Paxos Algorithm Note","description":"学习 PaxosStore 中的 Paxos 实现。","keywords":["algorithm","paxos"],"articleBody":"Paxos 协议与工程实现 写在前面，我没有完整实现过 Paxos 协议，不敢保证下面描述的内容完全正确。本文主要是学习的笔记，如果有错误，十分欢迎指出，大家一起讨论学习。\n本文所有内容都是参考 PaxosStore 论文 《PaxosStore: High-availability Storage Made Practical in WeChat》\n概念定义 为了后续方便描述，我们先定义会用到的概念\nProposal 提议，包含提议号和提议值； Prepare 第一阶段 Proposer 发出的请求，包含一个提议号； Promise 第一阶段 Proposer 回应的消息，包含一个提议号和一个（如果有）已经 Accepted 的最大提仪； Accept 第二阶段 Proposer 发出的请求，包含一个提议号和一个提议值； Accepted 第二阶段 Proposer 回应的消息，包含一个提议号。也表示一个提议被一个该 Proposer 接受； Chosen 代表一个提议被大多数的 Proposer 接受，不会再发生改变； Proposer 提议成员； Acceptor 发送 Accepted 消息的成员； Learner 学习者，不参与 Paxos 投票过程。 与可以用代码语言描述，参考 链接\n// Prepare 请求，包含一个提议号 struct Prepare { int n; }; // 在收到大多数的 Promised 请求后，发出的 Accept 请求，包含一个提仪号以及一个值。 // 这个值是 Promised 中最大提议号的值，如果所有 promised 都没有返回值，则可以自己提出任意值。 // 对应到工程实现上，则代表这个位置已经被占了，可以再起一轮新 paxos struct Accept { int n; void *value; }; // n 承诺不 accept 小于 n 的 accept 请求，返回当时最大提议号对应的值。 struct Promised { int n; Accept *proposal = nullptr; }; // 如果满足承诺，返回最大的提议号 struct Accepted { int n; }; // paxos 成员会在内存中纪录的值，包括最大的提议号，以及对应的值。 class Acceptor { int last_n = 0; Accept *proposal = nullptr; }; Basic Paxos 协议 Basic Paxos 是理论上的最基础的一致性算法，作用是：多个（奇数）成员确定唯一一个值。\n算法分为两轮，第一轮 Prepare 请求会得到承诺后续不通过小于本次 Prepare.n 的提议，同时返回自己已经 accepted 的最大提议。第二轮 Accept 请求会带上上一轮收到的最大提议值（如果没有，则可以自己提出），每个 Acceptor 在不违背承诺的情况下更新本地状态。\n一个提仪一旦被大多数结果 accepted，就会被认为是 chosen。对于一个值来说，accepted 还是可以变的，chosen 的永远不会变。一组经典的 paxos 实例只能确定（chosen）一个值。\n算法的详细描述可以参考论文：\nPhase 1.\nA proposer selects a proposal number n and sends a prepare request with number n to a majority of acceptors.\nIf an acceptor receives a prepare request with number n greater than that of any prepare request to which it has already responded, then it responds to the request with a promise not to accept any more proposals numbered less than n and with the highest-numbered proposal (if any) that it has accepted.\nPhase 2.\nIf the proposer receives a response to its prepare requests (numbered n) from a majority of acceptors, then it sends an accept request to each of those acceptors for a proposal numbered n with a value v, where v is the value of the highest-numbered proposal among the responses, or is any value if the responses reported no proposals.\nIf an acceptor receives an accept request for a proposal numbered n, it accepts the proposal unless it has already responded to a prepare request having a number greater than n.\n注意细节：\nAccept 请求中的 value 是一阶段返回所有 promised 中 n 最大的那个值。是 promised→proposal.n 的 n，而不是 promised.n acceptor 上 accept 值还是会被修改的。 在提议被大多数通过的一瞬间，这个值就确定下来了，再也不会被修改。 对于证明的思路是这么一种思路：证明一个值 chosen 不会被修改，可以通过加强的方式。如果一个大于当前提仪号并且值不同的提仪，不会被发出。chosen 的值自然就不会被修改。\nMulti Paxos 实现方法 可以看到，Basic Paxos 算法只能确定一个值，同时要走两轮流程。为了在真实系统上实际使用起来，还需要做一些修改优化。\n我们可以在 Basic Paxos 上增加一个 Entry ID 的维度，每个 Entry 保存一个值。同时，可以在第 i 个 Entry 中携带上第 i+1 个 Entry 的 Prepare 信息：当 $E_i$ 被 chosen 时，同时认为 $E_i+1$ 已经完成了 prepare 流程。\n工程实现上的问题 论文只描述了 Paxos 算法的流程和证明，在实际实现上，还有很多细节要处理，例如怎么 CatchUp、怎么 GetALL以及一些细节的问题。\n写读读问题 写读读的问题场景：假设三机日志都commit到了Entry 100，然后机器 A执行 Entry 101 的二轮过程然后挂掉。这个时候会读到 100 的值。然后机器 A 恢复同步状态到 BC，后续就读到了 Entry 101。\n重复执行问题 重复执行的问题场景：机器 A 收到一个写请求，在执行完 Paxos 后被 chosen，然后发送响应给客户端。这个响应可能因为网络原因未发到或者超时。然后客户端超时后重发请求到机器 B。机器 B 重新跑一次 Paxos 过程，然后回复客户端。这儿更新过程就会执行两次，如果是有状态的更新就会有问题。\n所以要让请求幂等，方法就是在请求上带上 request ID， svr 端检查 request ID 。\nThe request ID is generated by the client and sent together with the write request, and checked by the PaxosStore node to detect potential duplication of actual request handling.\nPlogKV 实现问题 文章同时提到了一个 PaxosLog for KV Data，可以优化掉 DB 部分的成本。那么正常的plog存储的key应该是entityid和entryid？怎么用key来查询？\n答案是只维护两个entry，一个最新chosen，一个pending。每个 key 都是一个 paxos 实例。\n参考 https://sf-zhou.github.io/paxos/paxos_store_03_consensus.html http://www.vldb.org/pvldb/vol10/p1730-lin.pdf ","wordCount":"1785","inLanguage":"en","datePublished":"2022-06-26T20:02:45+08:00","dateModified":"2022-06-26T20:02:45+08:00","author":[{"@type":"Person","name":"Chang Liu"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.liuchang0812.com/posts/tech/os/paxos-note/"},"publisher":{"@type":"Organization","name":"​Tech and Text Tales","logo":{"@type":"ImageObject","url":"https://www.liuchang0812.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.liuchang0812.com/ accesskey=h title="​Tech and Text Tales (Alt + H)">​Tech and Text Tales</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://www.liuchang0812.com/posts title=📚文章><span>📚文章</span></a></li><li><a href=https://www.liuchang0812.com/search/ title=🔍搜索><span>🔍搜索</span></a></li><li><a href=https://www.liuchang0812.com/archives/ title=⏱时间轴><span>⏱时间轴</span></a></li><li><a href=https://www.liuchang0812.com/about/ title=🙋🏻‍♂️关于><span>🙋🏻‍♂️关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://www.liuchang0812.com/>Home</a>&nbsp;»&nbsp;<a href=https://www.liuchang0812.com/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Paxos Algorithm Note</h1><div class=post-description>学习 PaxosStore 中的 Paxos 实现。</div><div class=post-meta><span title='2022-06-26 20:02:45 +0800 +0800'>2022-06-26</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Chang Liu</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#paxos-%e5%8d%8f%e8%ae%ae%e4%b8%8e%e5%b7%a5%e7%a8%8b%e5%ae%9e%e7%8e%b0 aria-label="Paxos 协议与工程实现">Paxos 协议与工程实现</a></li><li><a href=#%e6%a6%82%e5%bf%b5%e5%ae%9a%e4%b9%89 aria-label=概念定义>概念定义</a></li><li><a href=#basic-paxos-%e5%8d%8f%e8%ae%ae aria-label="Basic Paxos 协议">Basic Paxos 协议</a></li><li><a href=#multi-paxos-%e5%ae%9e%e7%8e%b0%e6%96%b9%e6%b3%95 aria-label="Multi Paxos 实现方法">Multi Paxos 实现方法</a></li><li><a href=#%e5%b7%a5%e7%a8%8b%e5%ae%9e%e7%8e%b0%e4%b8%8a%e7%9a%84%e9%97%ae%e9%a2%98 aria-label=工程实现上的问题>工程实现上的问题</a><ul><li><a href=#%e5%86%99%e8%af%bb%e8%af%bb%e9%97%ae%e9%a2%98 aria-label=写读读问题>写读读问题</a></li><li><a href=#%e9%87%8d%e5%a4%8d%e6%89%a7%e8%a1%8c%e9%97%ae%e9%a2%98 aria-label=重复执行问题>重复执行问题</a></li></ul></li><li><a href=#plogkv-%e5%ae%9e%e7%8e%b0%e9%97%ae%e9%a2%98 aria-label="PlogKV 实现问题">PlogKV 实现问题</a></li><li><a href=#%e5%8f%82%e8%80%83 aria-label=参考>参考</a></li></ul></div></details></div><div class=post-content><h1 id=paxos-协议与工程实现>Paxos 协议与工程实现<a hidden class=anchor aria-hidden=true href=#paxos-协议与工程实现>#</a></h1><blockquote><p>写在前面，我没有完整实现过 Paxos 协议，不敢保证下面描述的内容完全正确。本文主要是学习的笔记，如果有错误，十分欢迎指出，大家一起讨论学习。</p></blockquote><blockquote><p>本文所有内容都是参考 <a href=http://www.vldb.org/pvldb/vol10/p1730-lin.pdf>PaxosStore</a> 论文 《PaxosStore: High-availability Storage Made Practical in WeChat》</p></blockquote><h1 id=概念定义>概念定义<a hidden class=anchor aria-hidden=true href=#概念定义>#</a></h1><p>为了后续方便描述，我们先定义会用到的概念</p><ul><li>Proposal 提议，包含提议号和提议值；</li><li>Prepare 第一阶段 Proposer 发出的请求，包含一个提议号；</li><li>Promise 第一阶段 Proposer 回应的消息，包含一个提议号和一个（如果有）已经 Accepted 的最大提仪；</li><li>Accept 第二阶段 Proposer 发出的请求，包含一个提议号和一个提议值；</li><li>Accepted 第二阶段 Proposer 回应的消息，包含一个提议号。也表示一个提议被一个该 Proposer 接受；</li><li>Chosen 代表一个提议被大多数的 Proposer 接受，不会再发生改变；</li><li>Proposer 提议成员；</li><li>Acceptor 发送 Accepted 消息的成员；</li><li>Learner 学习者，不参与 Paxos 投票过程。</li></ul><p>与可以用代码语言描述，参考 <a href=https://sf-zhou.github.io/paxos/paxos_store_03_consensus.html>链接</a></p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007f7f>// Prepare 请求，包含一个提议号
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>struct</span> Prepare {
</span></span><span style=display:flex><span>  <span style=color:#fff;font-weight:700>int</span> n;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#007f7f>// 在收到大多数的 Promised 请求后，发出的 Accept 请求，包含一个提仪号以及一个值。
</span></span></span><span style=display:flex><span><span style=color:#007f7f>// 这个值是 Promised 中最大提议号的值，如果所有 promised 都没有返回值，则可以自己提出任意值。
</span></span></span><span style=display:flex><span><span style=color:#007f7f>// 对应到工程实现上，则代表这个位置已经被占了，可以再起一轮新 paxos
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>struct</span> Accept {
</span></span><span style=display:flex><span>  <span style=color:#fff;font-weight:700>int</span> n;
</span></span><span style=display:flex><span>  <span style=color:#fff;font-weight:700>void</span> *value;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#007f7f>// n 承诺不 accept 小于 n 的 accept 请求，返回当时最大提议号对应的值。
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>struct</span> Promised {
</span></span><span style=display:flex><span>  <span style=color:#fff;font-weight:700>int</span> n;
</span></span><span style=display:flex><span>  Accept *proposal = <span style=color:#fff;font-weight:700>nullptr</span>;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#007f7f>// 如果满足承诺，返回最大的提议号
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>struct</span> Accepted {
</span></span><span style=display:flex><span>  <span style=color:#fff;font-weight:700>int</span> n;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#007f7f>// paxos 成员会在内存中纪录的值，包括最大的提议号，以及对应的值。
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>class</span> Acceptor {
</span></span><span style=display:flex><span>  <span style=color:#fff;font-weight:700>int</span> last_n = <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>  Accept *proposal = <span style=color:#fff;font-weight:700>nullptr</span>;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h1 id=basic-paxos-协议>Basic Paxos 协议<a hidden class=anchor aria-hidden=true href=#basic-paxos-协议>#</a></h1><p><code>Basic Paxos</code> 是理论上的最基础的一致性算法，作用是：<strong>多个（奇数）成员确定唯一一个值。</strong></p><p>算法分为两轮，第一轮 Prepare 请求会得到承诺后续不通过小于本次 Prepare.n 的提议，同时返回自己已经 accepted 的最大提议。第二轮 Accept 请求会带上上一轮收到的最大提议值（如果没有，则可以自己提出），每个 Acceptor 在不违背承诺的情况下更新本地状态。</p><p>一个提仪一旦被大多数结果 accepted，就会被认为是 chosen。对于一个值来说，accepted 还是可以变的，chosen 的永远不会变。一组经典的 paxos 实例只能确定（chosen）一个值。</p><p>算法的详细描述可以参考论文：</p><p><strong>Phase 1.</strong></p><ol><li><p>A proposer selects a proposal number n and sends a prepare request with number n to a majority of acceptors.</p></li><li><p>If an acceptor receives a prepare request with number n greater than that of any prepare request to which it has already responded, then it responds to the request with a promise not to accept any more proposals numbered less than n and with the highest-numbered proposal (if any) that it has accepted.</p></li></ol><p><strong>Phase 2.</strong></p><ol><li><p>If the proposer receives a response to its prepare requests (numbered n) from a majority of acceptors, then it sends an accept request to each of those acceptors for a proposal numbered n with a value <em>v</em>, where v is the value of the highest-numbered proposal among the responses, or is any value if the responses reported no proposals.</p></li><li><p>If an acceptor receives an accept request for a proposal numbered n, it accepts the proposal unless it has already responded to a prepare request having a number greater than n.</p></li></ol><p>注意细节：</p><ol><li>Accept 请求中的 value 是一阶段返回所有 promised 中 n 最大的那个值。是 promised→proposal.n 的 n，而不是 promised.n</li><li>acceptor 上 accept 值还是会被修改的。</li><li>在提议被大多数通过的一瞬间，这个值就确定下来了，再也不会被修改。</li></ol><p>对于证明的思路是这么一种思路：证明一个值 chosen 不会被修改，可以通过加强的方式。如果一个大于当前提仪号并且值不同的提仪，不会被发出。chosen 的值自然就不会被修改。</p><h1 id=multi-paxos-实现方法>Multi Paxos 实现方法<a hidden class=anchor aria-hidden=true href=#multi-paxos-实现方法>#</a></h1><p>可以看到，Basic Paxos 算法只能确定一个值，同时要走两轮流程。为了在真实系统上实际使用起来，还需要做一些修改优化。</p><p>我们可以在 Basic Paxos 上增加一个 Entry ID 的维度，每个 Entry 保存一个值。同时，可以在第 i 个 Entry 中携带上第 i+1 个 Entry 的 Prepare 信息：当 $E_i$ 被 <code>chosen</code> 时，同时认为 $E_i+1$ 已经完成了 <code>prepare</code> 流程。</p><h1 id=工程实现上的问题>工程实现上的问题<a hidden class=anchor aria-hidden=true href=#工程实现上的问题>#</a></h1><p>论文只描述了 Paxos 算法的流程和证明，在实际实现上，还有很多细节要处理，例如怎么 CatchUp、怎么 GetALL以及一些细节的问题。</p><h2 id=写读读问题>写读读问题<a hidden class=anchor aria-hidden=true href=#写读读问题>#</a></h2><p>写读读的问题场景：假设三机日志都commit到了Entry 100，然后机器 A执行 Entry 101 的二轮过程然后挂掉。这个时候会读到 100 的值。然后机器 A 恢复同步状态到 BC，后续就读到了 Entry 101。</p><h2 id=重复执行问题>重复执行问题<a hidden class=anchor aria-hidden=true href=#重复执行问题>#</a></h2><p>重复执行的问题场景：机器 A 收到一个写请求，在执行完 Paxos 后被 chosen，然后发送响应给客户端。这个响应可能因为网络原因未发到或者超时。然后客户端超时后重发请求到机器 B。机器 B 重新跑一次 Paxos 过程，然后回复客户端。这儿更新过程就会执行两次，如果是有状态的更新就会有问题。</p><p>所以要让请求幂等，方法就是在请求上带上 request ID， svr 端检查 request ID 。</p><blockquote><p>The request ID is generated by the client and sent together with the write request, and checked by the PaxosStore node to detect potential duplication of actual request handling.</p></blockquote><p><img loading=lazy src=https://cdn.jsdelivr.net/gh/liuchang0812/liuchang0812.github.io/content/posts/tech/os/paxos-note/https:/imgs-1252230511.cos.ap-shanghai.myqcloud.com/2206/paxoslog.png alt=paxoslog></p><h1 id=plogkv-实现问题>PlogKV 实现问题<a hidden class=anchor aria-hidden=true href=#plogkv-实现问题>#</a></h1><p>文章同时提到了一个 PaxosLog for KV Data，可以优化掉 DB 部分的成本。那么正常的plog存储的key应该是entityid和entryid？怎么用key来查询？</p><p>答案是只维护两个entry，一个最新chosen，一个pending。每个 key 都是一个 paxos 实例。</p><p><img loading=lazy src=https://cdn.jsdelivr.net/gh/liuchang0812/liuchang0812.github.io/content/posts/tech/os/paxos-note/https:/imgs-1252230511.cos.ap-shanghai.myqcloud.com/2206/plogkv.png alt=plogkv></p><h1 id=参考>参考<a hidden class=anchor aria-hidden=true href=#参考>#</a></h1><ol><li><a href=https://sf-zhou.github.io/paxos/paxos_store_03_consensus.html>https://sf-zhou.github.io/paxos/paxos_store_03_consensus.html</a></li><li><a href=http://www.vldb.org/pvldb/vol10/p1730-lin.pdf>http://www.vldb.org/pvldb/vol10/p1730-lin.pdf</a></li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://www.liuchang0812.com/tags/algorithm/>Algorithm</a></li><li><a href=https://www.liuchang0812.com/tags/paxos/>Paxos</a></li></ul><nav class=paginav><a class=prev href=https://www.liuchang0812.com/posts/tech/os/libco-usage/><span class=title>« Prev</span><br><span>libco usage</span>
</a><a class=next href=https://www.liuchang0812.com/posts/tech/os/cgroup/><span class=title>Next »</span><br><span>cgroup usage</span></a></nav></footer><div id=gitalk-container></div><script>const gitalk=new Gitalk({clientID:"402f41759b3537b6c752",clientSecret:"d9558424431bfc3ee18d4b6c6ce7594ef682a701",repo:"liuchang0812.github.io",owner:"liuchang0812",admin:["liuchang0812"],id:location.pathname,distractionFreeMode:!1});gitalk.render("gitalk-container")</script></article></main><footer class=footer><span>&copy; 2025 <a href=https://www.liuchang0812.com/>​Tech and Text Tales</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>