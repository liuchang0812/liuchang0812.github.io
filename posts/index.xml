<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Posts on ​Tech and Text Tales</title><link>https://www.liuchang0812.com/posts/</link><description>Recent content in Posts on ​Tech and Text Tales</description><generator>Hugo -- 0.135.0</generator><language>zh-cn</language><lastBuildDate>Mon, 05 May 2025 22:44:51 +0800</lastBuildDate><atom:link href="https://www.liuchang0812.com/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Google File System 设计</title><link>https://www.liuchang0812.com/posts/tech/paper/gfs/</link><pubDate>Mon, 05 May 2025 22:44:51 +0800</pubDate><guid>https://www.liuchang0812.com/posts/tech/paper/gfs/</guid><description>2025 年回头看 2003 年的 Google File System 设计</description></item><item><title>自动微分系统实现</title><link>https://www.liuchang0812.com/posts/tech/ai/autograd/</link><pubDate>Mon, 28 Apr 2025 23:49:51 +0800</pubDate><guid>https://www.liuchang0812.com/posts/tech/ai/autograd/</guid><description>学习一下怎么实现机器学习框架🚀</description></item><item><title>控制论算法 PID</title><link>https://www.liuchang0812.com/posts/tech/pid/</link><pubDate>Wed, 16 Apr 2025 20:49:51 +0800</pubDate><guid>https://www.liuchang0812.com/posts/tech/pid/</guid><description>学习一下怎么控制火箭🚀</description></item><item><title>语言模型和词向量</title><link>https://www.liuchang0812.com/posts/tech/ai/word2vec/</link><pubDate>Wed, 02 Apr 2025 23:49:51 +0800</pubDate><guid>https://www.liuchang0812.com/posts/tech/ai/word2vec/</guid><description>语言模型和词向量笔记， deepseek 优化版</description></item><item><title>《不要因为走得太远而忘记为什么出发》</title><link>https://www.liuchang0812.com/posts/read/250324-chenmang/</link><pubDate>Mon, 24 Mar 2025 20:18:34 +0800</pubDate><guid>https://www.liuchang0812.com/posts/read/250324-chenmang/</guid><description>东方时空制片人陈虻的一些话和思考</description></item><item><title>《走出戈壁》 单伟健</title><link>https://www.liuchang0812.com/posts/read/25-03-out-of-the-gobi/</link><pubDate>Thu, 13 Mar 2025 23:18:34 +0800</pubDate><guid>https://www.liuchang0812.com/posts/read/25-03-out-of-the-gobi/</guid><description>从戈壁滩走到美国，我是如何成为沃顿商学院教授的</description></item><item><title>金钱博弈 单伟健</title><link>https://www.liuchang0812.com/posts/read/money-game/</link><pubDate>Wed, 12 Mar 2025 00:18:34 +0800</pubDate><guid>https://www.liuchang0812.com/posts/read/money-game/</guid><description>想知道怎么收购一家银行吗？</description></item><item><title>陈云传</title><link>https://www.liuchang0812.com/posts/read/chen-yun/</link><pubDate>Fri, 29 Nov 2024 21:47:16 +0800</pubDate><guid>https://www.liuchang0812.com/posts/read/chen-yun/</guid><description>他**了中国系列传记</description></item><item><title>现代化的源码阅读方法</title><link>https://www.liuchang0812.com/posts/tech/read-code-vscode/clangd/</link><pubDate>Mon, 18 Nov 2024 22:05:42 +0800</pubDate><guid>https://www.liuchang0812.com/posts/tech/read-code-vscode/clangd/</guid><description>现代化的源码阅读方法</description></item><item><title>并发编程中的状态机</title><link>https://www.liuchang0812.com/posts/tech/leetcode/state-machine-in-concurrency/</link><pubDate>Thu, 15 Aug 2024 23:34:58 +0800</pubDate><guid>https://www.liuchang0812.com/posts/tech/leetcode/state-machine-in-concurrency/</guid><description>使用状态机思路解决一个并行问题</description></item><item><title>2023 11 读书分享</title><link>https://www.liuchang0812.com/posts/read/2023-11/</link><pubDate>Wed, 29 Nov 2023 20:52:14 +0800</pubDate><guid>https://www.liuchang0812.com/posts/read/2023-11/</guid><description>&lt;p>最近主要读了《民主的细节》《芯片战争》和新出的《Elon Musk》几本书。《芯片战争》是在飞机上快速翻了一遍。《民主的细节》是因为前段时间《巨变第二天》特别火，国内还买不到，所以找了一下作者其它著作。《Elon Musk》则是在公司读书活动上白嫖的。&lt;/p></description></item><item><title>2023 07 读书分享：清代地方政府</title><link>https://www.liuchang0812.com/posts/read/2023-07/</link><pubDate>Mon, 31 Jul 2023 22:11:33 +0800</pubDate><guid>https://www.liuchang0812.com/posts/read/2023-07/</guid><description>2023 07 读书分享：清代地方政府</description></item><item><title>2023 06 读书分享：被统治的艺术</title><link>https://www.liuchang0812.com/posts/read/2023-06-reading/</link><pubDate>Tue, 04 Jul 2023 11:58:05 +0800</pubDate><guid>https://www.liuchang0812.com/posts/read/2023-06-reading/</guid><description>&lt;p>强烈推荐，书的排版很好，翻译的也特别好。比较有意思的是前半部分，介绍了明代的世袭军户制度下，人们从想办法减少服役代价，到利用制度来进行套利的方法，以及制度对人们生活文化的影响。&lt;/p></description></item><item><title>2023 05 读书分享：城乡中国、王氏之死</title><link>https://www.liuchang0812.com/posts/read/2023-05/</link><pubDate>Mon, 05 Jun 2023 22:11:33 +0800</pubDate><guid>https://www.liuchang0812.com/posts/read/2023-05/</guid><description>2305 读书分享</description></item><item><title>2023 04 读书分享：漫长的余生、父母的语言</title><link>https://www.liuchang0812.com/posts/read/2023-04/</link><pubDate>Thu, 04 May 2023 13:09:42 +0800</pubDate><guid>https://www.liuchang0812.com/posts/read/2023-04/</guid><description>&lt;h1 id="漫长的余生">漫长的余生&lt;/h1>
&lt;ul>
&lt;li>书名不好，书很不错。这种书名放在面前都可能不会被注意到。&lt;/li>
&lt;li>作者希望用宫女王钟儿作为线索，介绍北魏的一段历史。但是实际读起来，感觉意义不大，不如直述。&lt;/li>
&lt;li>之前对魏晋南北朝这段历史了解不多，读这本书还是比较吃力（人物名字太相似），但是北魏的历史还挺有意思。搜了一下国内有一部电视剧叫 &lt;a href="http://www.baidu.com/link?url=akjxbWw6ixiptByKVDLG2VIBI_yUExzjgByrhypkvDc1HDzHfrUvnCVa_-IS9LxsXC2D4auS8y8hPGs2NxFNrgyfiqw1Rxtx6HaL9jhK9d1R6pnMtCqOm1RQ5WSLPqrU">胡笳汉月&lt;/a>，可惜没有过审，被剪成了几集历史纪录片。&lt;/li>
&lt;li>需要把主要人物的关系图整理一下，才能更好理解。&lt;/li>
&lt;li>^^子贵母死^^ 的制度真是残忍，本来是为了避免外戚乱权，却被几任皇太后利用来维持自己的地位。&lt;/li>
&lt;/ul>
&lt;div class="mermaid">%%{init: {'theme':'neutral'}}%%
flowchart TD
XiaoWD[孝文帝]
FHH[冯皇后]
CTH[常太后]
WCD[文成帝]
XianWD[献文帝]
DFHH[大冯皇后]
XFHH[小冯皇后]
XWD[宣武帝]
GZR[高照容]
YX[元恂]
subgraph 皇帝
WCD==长子==>XianWD==长子==>XiaoWD==次子==>XWD
XiaoWD==长子==>YX
end
subgraph 皇后
CTH--选立-->FHH
FHH--侄女-->DFHH
FHH--侄女-->XFHH
DFHH--杀死-->GZR
end
CTH--乳母-->WCD
FHH--乳母-->XianWD
FHH--杀死生母从小抚养-->XiaoWD
XiaoWD--皇后-->DFHH
XiaoWD--皇后-->XFHH
GZR--生母-->XWD
DFHH--抚养-->XWD
XFHH--抚养-->YX
&lt;/div>
&lt;h1 id="父母的语言">父母的语言&lt;/h1>
&lt;p>这本书的核心观点是小朋友3岁前接受到语言词汇对于智力发育有很大的影响。按照作者统计，经济差异大的家庭之间有3 kw的单词数差异。&lt;/p></description></item><item><title>2023 03 读书分享</title><link>https://www.liuchang0812.com/posts/read/2023-03-reading/</link><pubDate>Wed, 12 Apr 2023 23:43:04 +0800</pubDate><guid>https://www.liuchang0812.com/posts/read/2023-03-reading/</guid><description>&lt;h1 id="小镇喧嚣一个乡镇政治运作的演绎与阐释">小镇喧嚣：一个乡镇政治运作的演绎与阐释&lt;/h1>
&lt;p>推荐，华科大教授写的一本书，记录了在小镇调查的一年半期间遇到的事情，主要包括：镇政府如何处理上级检查，乡镇村干部如何收农业税，如何处理各种农村冲突上访等。&lt;/p></description></item><item><title>2023 02 读书分享</title><link>https://www.liuchang0812.com/posts/read/2023-02-reading/</link><pubDate>Fri, 03 Mar 2023 20:06:29 +0800</pubDate><guid>https://www.liuchang0812.com/posts/read/2023-02-reading/</guid><description>分享一下最近读的书</description></item><item><title>libco usage</title><link>https://www.liuchang0812.com/posts/tech/os/libco-usage/</link><pubDate>Tue, 06 Sep 2022 21:00:54 +0800</pubDate><guid>https://www.liuchang0812.com/posts/tech/os/libco-usage/</guid><description>this note shares libco coroutine usage</description></item><item><title>Paxos Algorithm Note</title><link>https://www.liuchang0812.com/posts/tech/os/paxos-note/</link><pubDate>Sun, 26 Jun 2022 20:02:45 +0800</pubDate><guid>https://www.liuchang0812.com/posts/tech/os/paxos-note/</guid><description>学习 PaxosStore 中的 Paxos 实现。</description></item><item><title>cgroup usage</title><link>https://www.liuchang0812.com/posts/tech/os/cgroup/</link><pubDate>Sun, 26 Jun 2022 19:29:52 +0800</pubDate><guid>https://www.liuchang0812.com/posts/tech/os/cgroup/</guid><description>cgroup 介绍与使用方法</description></item><item><title>Why Does Conv Need a Mutex</title><link>https://www.liuchang0812.com/posts/tech/os/why-conv-need-a-mutex/</link><pubDate>Thu, 23 Jun 2022 17:29:52 +0800</pubDate><guid>https://www.liuchang0812.com/posts/tech/os/why-conv-need-a-mutex/</guid><description>为什么信号量还需要一个互斥锁保护？</description></item><item><title>2022 05 读书分享</title><link>https://www.liuchang0812.com/posts/read/2022-05-reading/</link><pubDate>Sat, 04 Jun 2022 21:22:37 +0800</pubDate><guid>https://www.liuchang0812.com/posts/read/2022-05-reading/</guid><description>介绍 22 年 5 月读的几本书</description></item><item><title>2267. 检查是否有合法括号字符串路径</title><link>https://www.liuchang0812.com/posts/tech/leetcode/2267/</link><pubDate>Wed, 11 May 2022 22:42:51 +0800</pubDate><guid>https://www.liuchang0812.com/posts/tech/leetcode/2267/</guid><description>&lt;p>记忆化搜索，刚好卡过去&lt;/p>
&lt;blockquote>
&lt;p>执行用时：1964 ms, 在所有 C++ 提交中击败了 5.08% 的用户&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">int&lt;/span> mem[&lt;span style="color:#ff0;font-weight:bold">100&lt;/span>][&lt;span style="color:#ff0;font-weight:bold">100&lt;/span>][&lt;span style="color:#ff0;font-weight:bold">100&lt;/span>][&lt;span style="color:#ff0;font-weight:bold">100&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fff;font-weight:bold">class&lt;/span> Solution {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fff;font-weight:bold">public&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007f7f">// 0 unknow
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007f7f">&lt;/span> &lt;span style="color:#007f7f">// 1 true
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007f7f">&lt;/span> &lt;span style="color:#007f7f">// 2 false
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007f7f">&lt;/span> &lt;span style="color:#fff;font-weight:bold">bool&lt;/span> dfs(&lt;span style="color:#fff;font-weight:bold">const&lt;/span> vector&amp;lt;vector&amp;lt;&lt;span style="color:#fff;font-weight:bold">char&lt;/span>&amp;gt;&amp;gt;&amp;amp; grid, &lt;span style="color:#fff;font-weight:bold">int&lt;/span> x1, &lt;span style="color:#fff;font-weight:bold">int&lt;/span> y1, &lt;span style="color:#fff;font-weight:bold">int&lt;/span> x2, &lt;span style="color:#fff;font-weight:bold">int&lt;/span> y2) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">if&lt;/span> (x1 &amp;gt;= grid.size() || x2 &amp;gt;= grid.size() || y1&amp;gt;=grid[&lt;span style="color:#ff0;font-weight:bold">0&lt;/span>].size() || y2 &amp;lt; &lt;span style="color:#ff0;font-weight:bold">0&lt;/span> || x2 &amp;lt; &lt;span style="color:#ff0;font-weight:bold">0&lt;/span> || x1 &amp;gt; x2 || y1 &amp;gt; y2)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">return&lt;/span> &lt;span style="color:#fff;font-weight:bold">false&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">if&lt;/span> ((x2 - x1 + y2 - y1)%&lt;span style="color:#ff0;font-weight:bold">2&lt;/span>==&lt;span style="color:#ff0;font-weight:bold">0&lt;/span>) &lt;span style="color:#fff;font-weight:bold">return&lt;/span> &lt;span style="color:#fff;font-weight:bold">false&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">if&lt;/span> (mem[x1][y1][x2][y2] != &lt;span style="color:#ff0;font-weight:bold">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">return&lt;/span> mem[x1][y1][x2][y2] == &lt;span style="color:#ff0;font-weight:bold">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">if&lt;/span> ( x2 - x1 + y2 - y1 == &lt;span style="color:#ff0;font-weight:bold">1&lt;/span> &amp;amp;&amp;amp; grid[x1][y1] == &lt;span style="color:#0ff;font-weight:bold">&amp;#39;(&amp;#39;&lt;/span> &amp;amp;&amp;amp; grid[x2][y2] == &lt;span style="color:#0ff;font-weight:bold">&amp;#39;)&amp;#39;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mem[x1][y1][x2][y2] = &lt;span style="color:#ff0;font-weight:bold">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">return&lt;/span> &lt;span style="color:#fff;font-weight:bold">true&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">if&lt;/span> (grid[x1][y1] == &lt;span style="color:#0ff;font-weight:bold">&amp;#39;(&amp;#39;&lt;/span> &amp;amp;&amp;amp; grid[x2][y2] == &lt;span style="color:#0ff;font-weight:bold">&amp;#39;)&amp;#39;&lt;/span>){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">bool&lt;/span> tmp = dfs(grid, x1+&lt;span style="color:#ff0;font-weight:bold">1&lt;/span>, y1, x2-&lt;span style="color:#ff0;font-weight:bold">1&lt;/span>, y2) ||
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dfs(grid, x1+&lt;span style="color:#ff0;font-weight:bold">1&lt;/span>, y1, x2, y2-&lt;span style="color:#ff0;font-weight:bold">1&lt;/span>) ||
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dfs(grid, x1, y1+&lt;span style="color:#ff0;font-weight:bold">1&lt;/span>, x2-&lt;span style="color:#ff0;font-weight:bold">1&lt;/span>, y2) ||
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dfs(grid, x1, y1+&lt;span style="color:#ff0;font-weight:bold">1&lt;/span>, x2, y2-&lt;span style="color:#ff0;font-weight:bold">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">if&lt;/span> (tmp) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mem[x1][y1][x2][y2] = &lt;span style="color:#ff0;font-weight:bold">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">return&lt;/span> &lt;span style="color:#fff;font-weight:bold">true&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">for&lt;/span> (&lt;span style="color:#fff;font-weight:bold">int&lt;/span> i=x1; i&amp;lt;=x2; ++i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">for&lt;/span> (&lt;span style="color:#fff;font-weight:bold">int&lt;/span> j=y1; j&amp;lt;=y2; ++j) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">if&lt;/span> (i == x1 &amp;amp;&amp;amp; j==y1) &lt;span style="color:#fff;font-weight:bold">continue&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">if&lt;/span> (i == x2 &amp;amp;&amp;amp; j==y2) &lt;span style="color:#fff;font-weight:bold">continue&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">if&lt;/span> ((dfs(grid, x1, y1, i, j) &amp;amp;&amp;amp; dfs(grid, i, j+&lt;span style="color:#ff0;font-weight:bold">1&lt;/span>, x2, y2))) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mem[x1][y1][x2][y2] = &lt;span style="color:#ff0;font-weight:bold">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">return&lt;/span> &lt;span style="color:#fff;font-weight:bold">true&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">if&lt;/span> (dfs(grid, x1, y1, i, j) &amp;amp;&amp;amp; dfs(grid, i+&lt;span style="color:#ff0;font-weight:bold">1&lt;/span>, j, x2, y2)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mem[x1][y1][x2][y2] = &lt;span style="color:#ff0;font-weight:bold">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">return&lt;/span> &lt;span style="color:#fff;font-weight:bold">true&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mem[x1][y1][x2][y2] = &lt;span style="color:#ff0;font-weight:bold">2&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">return&lt;/span> &lt;span style="color:#fff;font-weight:bold">false&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mem[x1][y1][x2][y2] = &lt;span style="color:#ff0;font-weight:bold">2&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">return&lt;/span> &lt;span style="color:#fff;font-weight:bold">false&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">bool&lt;/span> hasValidPath(vector&amp;lt;vector&amp;lt;&lt;span style="color:#fff;font-weight:bold">char&lt;/span>&amp;gt;&amp;gt;&amp;amp; grid) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">int&lt;/span> row = grid.size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">int&lt;/span> col = grid[&lt;span style="color:#ff0;font-weight:bold">0&lt;/span>].size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">if&lt;/span> ((row + col)%&lt;span style="color:#ff0;font-weight:bold">2&lt;/span>==&lt;span style="color:#ff0;font-weight:bold">0&lt;/span>) &lt;span style="color:#fff;font-weight:bold">return&lt;/span> &lt;span style="color:#fff;font-weight:bold">false&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">if&lt;/span> ( grid[&lt;span style="color:#ff0;font-weight:bold">0&lt;/span>][&lt;span style="color:#ff0;font-weight:bold">0&lt;/span>] == &lt;span style="color:#0ff;font-weight:bold">&amp;#39;)&amp;#39;&lt;/span> || grid[row - &lt;span style="color:#ff0;font-weight:bold">1&lt;/span>][col - &lt;span style="color:#ff0;font-weight:bold">1&lt;/span>] == &lt;span style="color:#0ff;font-weight:bold">&amp;#39;(&amp;#39;&lt;/span>) &lt;span style="color:#fff;font-weight:bold">return&lt;/span> &lt;span style="color:#fff;font-weight:bold">false&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> memset(mem, &lt;span style="color:#ff0;font-weight:bold">0&lt;/span>, &lt;span style="color:#fff;font-weight:bold">sizeof&lt;/span> mem);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">return&lt;/span> dfs(grid, &lt;span style="color:#ff0;font-weight:bold">0&lt;/span>, &lt;span style="color:#ff0;font-weight:bold">0&lt;/span>, row-&lt;span style="color:#ff0;font-weight:bold">1&lt;/span>, col -&lt;span style="color:#ff0;font-weight:bold">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>题解里面有一个写法很好，可以学习一下&lt;/p></description></item><item><title>2266. 统计打字方案数</title><link>https://www.liuchang0812.com/posts/tech/leetcode/leetcode2266/</link><pubDate>Tue, 10 May 2022 22:21:58 +0800</pubDate><guid>https://www.liuchang0812.com/posts/tech/leetcode/leetcode2266/</guid><description>&lt;p>爬楼梯的加强版本，分别提前生成三个字母和四个字母的 fib 数组，然后分组统计后相乘。代码如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fff;font-weight:bold">class&lt;/span> Solution {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fff;font-weight:bold">public&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">int&lt;/span> countTexts(string pressedKeys) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">int&lt;/span> f1[&lt;span style="color:#ff0;font-weight:bold">100005&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">int&lt;/span> f2[&lt;span style="color:#ff0;font-weight:bold">100005&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> memset(f1, &lt;span style="color:#ff0;font-weight:bold">0&lt;/span>, &lt;span style="color:#fff;font-weight:bold">sizeof&lt;/span> f1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> memset(f2, &lt;span style="color:#ff0;font-weight:bold">0&lt;/span>, &lt;span style="color:#fff;font-weight:bold">sizeof&lt;/span> f2);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> f1[&lt;span style="color:#ff0;font-weight:bold">0&lt;/span>] = &lt;span style="color:#ff0;font-weight:bold">1&lt;/span>; f1[&lt;span style="color:#ff0;font-weight:bold">1&lt;/span>] = &lt;span style="color:#ff0;font-weight:bold">2&lt;/span>; f1[&lt;span style="color:#ff0;font-weight:bold">2&lt;/span>] = &lt;span style="color:#ff0;font-weight:bold">4&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> f2[&lt;span style="color:#ff0;font-weight:bold">0&lt;/span>] = &lt;span style="color:#ff0;font-weight:bold">1&lt;/span>; f2[&lt;span style="color:#ff0;font-weight:bold">1&lt;/span>] = &lt;span style="color:#ff0;font-weight:bold">2&lt;/span>; f2[&lt;span style="color:#ff0;font-weight:bold">2&lt;/span>] = &lt;span style="color:#ff0;font-weight:bold">4&lt;/span>; f2[&lt;span style="color:#ff0;font-weight:bold">3&lt;/span>] = &lt;span style="color:#ff0;font-weight:bold">8&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">for&lt;/span> (&lt;span style="color:#fff;font-weight:bold">int&lt;/span> i=&lt;span style="color:#ff0;font-weight:bold">3&lt;/span>; i&amp;lt;&lt;span style="color:#ff0;font-weight:bold">100005&lt;/span>; ++i) f1[i] = (&lt;span style="color:#ff0;font-weight:bold">0LL&lt;/span> + f1[i-&lt;span style="color:#ff0;font-weight:bold">1&lt;/span>] + f1[i-&lt;span style="color:#ff0;font-weight:bold">2&lt;/span>] + f1[i-&lt;span style="color:#ff0;font-weight:bold">3&lt;/span>])%&lt;span style="color:#fff;font-weight:bold">int&lt;/span>(&lt;span style="color:#ff0;font-weight:bold">1e9&lt;/span>+&lt;span style="color:#ff0;font-weight:bold">7&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">for&lt;/span> (&lt;span style="color:#fff;font-weight:bold">int&lt;/span> i=&lt;span style="color:#ff0;font-weight:bold">4&lt;/span>; i&amp;lt;&lt;span style="color:#ff0;font-weight:bold">100005&lt;/span>; ++i) f2[i] = (&lt;span style="color:#ff0;font-weight:bold">0LL&lt;/span> + f2[i-&lt;span style="color:#ff0;font-weight:bold">1&lt;/span>] + f2[i-&lt;span style="color:#ff0;font-weight:bold">2&lt;/span>] + f2[i-&lt;span style="color:#ff0;font-weight:bold">3&lt;/span>] + f2[i-&lt;span style="color:#ff0;font-weight:bold">4&lt;/span>])%&lt;span style="color:#fff;font-weight:bold">int&lt;/span>(&lt;span style="color:#ff0;font-weight:bold">1e9&lt;/span>+&lt;span style="color:#ff0;font-weight:bold">7&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">int&lt;/span> ans = &lt;span style="color:#ff0;font-weight:bold">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">int&lt;/span> cur_ch = pressedKeys[&lt;span style="color:#ff0;font-weight:bold">0&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">int&lt;/span> cur_cnt = &lt;span style="color:#ff0;font-weight:bold">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">for&lt;/span> (&lt;span style="color:#fff;font-weight:bold">int&lt;/span> i=&lt;span style="color:#ff0;font-weight:bold">1&lt;/span>; i&amp;lt;pressedKeys.size(); ++i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">if&lt;/span> (pressedKeys[i] != cur_ch) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">if&lt;/span> (cur_ch == &lt;span style="color:#0ff;font-weight:bold">&amp;#39;7&amp;#39;&lt;/span> || cur_ch == &lt;span style="color:#0ff;font-weight:bold">&amp;#39;9&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ans = &lt;span style="color:#ff0;font-weight:bold">1LL&lt;/span> *ans * f2[cur_cnt - &lt;span style="color:#ff0;font-weight:bold">1&lt;/span>] % &lt;span style="color:#fff;font-weight:bold">int&lt;/span>(&lt;span style="color:#ff0;font-weight:bold">1e9&lt;/span>+&lt;span style="color:#ff0;font-weight:bold">7&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ans = &lt;span style="color:#ff0;font-weight:bold">1LL&lt;/span> *ans * f1[cur_cnt - &lt;span style="color:#ff0;font-weight:bold">1&lt;/span>] % &lt;span style="color:#fff;font-weight:bold">int&lt;/span>(&lt;span style="color:#ff0;font-weight:bold">1e9&lt;/span>+&lt;span style="color:#ff0;font-weight:bold">7&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cur_ch = pressedKeys[i];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cur_cnt = &lt;span style="color:#ff0;font-weight:bold">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#fff;font-weight:bold">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ++ cur_cnt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">if&lt;/span> (cur_ch == &lt;span style="color:#0ff;font-weight:bold">&amp;#39;7&amp;#39;&lt;/span> || cur_ch == &lt;span style="color:#0ff;font-weight:bold">&amp;#39;9&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ans = &lt;span style="color:#ff0;font-weight:bold">1LL&lt;/span> * ans * f2[cur_cnt - &lt;span style="color:#ff0;font-weight:bold">1&lt;/span>] % &lt;span style="color:#fff;font-weight:bold">int&lt;/span>(&lt;span style="color:#ff0;font-weight:bold">1e9&lt;/span>+&lt;span style="color:#ff0;font-weight:bold">7&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ans = &lt;span style="color:#ff0;font-weight:bold">1LL&lt;/span> * ans * f1[cur_cnt - &lt;span style="color:#ff0;font-weight:bold">1&lt;/span>] % &lt;span style="color:#fff;font-weight:bold">int&lt;/span>(&lt;span style="color:#ff0;font-weight:bold">1e9&lt;/span>+&lt;span style="color:#ff0;font-weight:bold">7&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">return&lt;/span> ans;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>2022 04 读书分享</title><link>https://www.liuchang0812.com/posts/read/2022-04-reading/</link><pubDate>Mon, 09 May 2022 20:06:29 +0800</pubDate><guid>https://www.liuchang0812.com/posts/read/2022-04-reading/</guid><description>&lt;h1 id="尘劫知青畅想曲">尘劫: 知青畅想曲&lt;/h1>
&lt;p>一本名字和封面看起来都非常像地摊文学的书，实际上却是“中共党史出版社”出版的关于知青的报告文学，内容包含了大量真实的知青故事，读来让人不禁唏嘘。&lt;/p></description></item><item><title>golang | error 的内部实现</title><link>https://www.liuchang0812.com/posts/tech/golang/error-impl/</link><pubDate>Sat, 07 May 2022 20:01:06 +0800</pubDate><guid>https://www.liuchang0812.com/posts/tech/golang/error-impl/</guid><description>&lt;p>Golang &lt;code>error&lt;/code> 是一个包含了 &lt;code>Error() string&lt;/code> 函数的接口，任何实现了 &lt;code>Error() string&lt;/code> 的结构体都可以认为是 &lt;code>error&lt;/code> 类型。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007f7f">// The error built-in interface type is the conventional interface for
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007f7f">// representing an error condition, with the nil value representing no error.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007f7f">&lt;/span>&lt;span style="color:#fff;font-weight:bold">type&lt;/span> &lt;span style="color:#fff;font-weight:bold">error&lt;/span> &lt;span style="color:#fff;font-weight:bold">interface&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Error() &lt;span style="color:#fff;font-weight:bold">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>对于简单场景，返回一个带字符串描述的 &lt;code>error&lt;/code> 可以通过 &lt;code>return errors.New(&amp;quot;this is a err&amp;quot;)&lt;/code> 来实现。其内部&lt;a href="https://go.dev/src/errors/errors.go#L58">实现&lt;/a>的机制为：定义了一个 &lt;code>errorString&lt;/code> 的结构体，调用 &lt;code>Error()&lt;/code> 的时候返回初始化时传入的字符串。&lt;/p></description></item><item><title>golang | []byte 和 string 的区别与适用场景</title><link>https://www.liuchang0812.com/posts/tech/golang/byte-slice-vs-string/</link><pubDate>Thu, 03 Mar 2022 10:44:06 +0800</pubDate><guid>https://www.liuchang0812.com/posts/tech/golang/byte-slice-vs-string/</guid><description>&lt;p>[]byte 和 string 有什么区别？类型转换需要拷贝数据吗？如何选择正确的类型？&lt;/p>
&lt;p>[]byte和string的类型字义非常类似，[]byte 比 string 多一个 cap 成员。string 在大多数的语言中都表示不可变字符串，[]byte 则是可以修改的数组分片。所以在做 []byte 和 string 转换的时候，如果只是简单的将指针复制，就相当于同一块内存同时有了可变和不可变引用，修改了 []byte 会影响到 string 的不可变性（rust 选手应该比较熟悉）。所以做类型转换时，会额外的有内存申请与数据拷贝动作。&lt;/p></description></item></channel></rss>